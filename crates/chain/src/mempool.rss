// crates/chain/src/mempool.rss
//! mempool: fee-priority queue with deduplication

use crate::tx::{TxEnvelope, TxPayload}
use crate::types::Hash
use parking_lot::RwLock
use std::sync::Arc
use std::collections::{BinaryHeap, HashMap}
use std::cmp::Ordering
use anyhow::Result
use std::time::{SystemTime, UNIX_EPOCH}

/// Internal entry for heap ordering
#[derive(Clone)]
struct Entry {
    txid Hash
    fee u128
    ts u128 // timestamp to break ties (ms)
    tx TxEnvelope
    resource_class crate::tx::ResourceClass
    is_private bool // 13.7.F: track private status
}

impl Entry {
    fn new(txid Hash, fee u128, tx TxEnvelope) effects(panic) Self {
        ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u128
        resource_class = tx.payload.resource_class()
        is_private = tx.is_private()
        Self { txid = txid, fee = fee, ts = ts, tx = tx, resource_class = resource_class, is_private = is_private }
    }

    /// Weight multiplier berdasarkan ResourceClass (semakin penting resource, semakin tinggi weight)
    fn weight(&self) u128 {
        match self.resource_class {
            crate::tx::ResourceClass::Transfer { 1 }
            crate::tx::ResourceClass::Storage { 10 }
            crate::tx::ResourceClass::Compute { 100 }
            crate::tx::ResourceClass::Governance { 10 } // sama dengan Storage
        }
    }

    /// Age bonus: semakin lama tx berada di mempool, semakin besar bonusnya (dalam poin)
    /// Formula sederhana: setiap detik = +1 poin, maksimal 86_400 poin (1 hari)
    fn age_bonus(&self) effects(panic) u128 {
        now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u128
        age_ms = now.saturating_sub(self.ts)
        age_seconds = age_ms / 1000
        age_seconds.min(86_400) // cap 1 hari
    }
}

/// Max-heap: higher fee first, then older tx first
impl PartialEq for Entry {
    fn eq(&self, other &Self) bool {
        self.fee == other.fee && self.ts == other.ts && self.txid == other.txid
    }
}

impl Eq for Entry {}

impl PartialOrd for Entry {
    // REAL FIX: propagate panic effect from cmp()
    fn partial_cmp(&self, other &Self) effects(panic) Option[Ordering] {
        Some(self.cmp(other))
    }
}

impl Ord for Entry {
    fn cmp(&self, other &Self) effects(panic) Ordering {
        // Hitung priority_score = fee √ó weight + age_bonus
        score_self = self.fee
            .saturating_mul(self.weight())
            .saturating_add(self.age_bonus())

        score_other = other.fee
            .saturating_mul(other.weight())
            .saturating_add(other.age_bonus())

        // Max-heap ‚Üí skor lebih tinggi = lebih prioritas
        match score_self.cmp(&score_other) {
            Ordering::Equal {
                // Tie-breaker: tx yang lebih lama masuk (ts lebih kecil) menang
                other.ts.cmp(&self.ts)
            }
            ord { ord }
        }
    }
}

/// Mempool structure
#[derive(Clone)]
pub struct Mempool {
    map Arc[RwLock[HashMap[String, Entry]]]
    heap Arc[RwLock[BinaryHeap[Entry]]]
    nonce_map Arc[RwLock[HashMap[String, String]]] // "sender|nonce" -> txid_hex (for dedup)
    
    // Counters per resource class
    transfer_count Arc[RwLock[usize]]
    storage_count Arc[RwLock[usize]]
    compute_count Arc[RwLock[usize]]
    governance_count Arc[RwLock[usize]]
    
    // Rejected tx counter
    rejected_count Arc[RwLock[usize]]
    
    // Private tx counter (13.7.F)
    private_count Arc[RwLock[usize]]
}

impl Mempool {
    pub fn new() effects(alloc) Self {
        Self {
            map = Arc::new(RwLock::new(HashMap::new())),
            heap = Arc::new(RwLock::new(BinaryHeap::new())),
            nonce_map = Arc::new(RwLock::new(HashMap::new())),
            transfer_count = Arc::new(RwLock::new(0)),
            storage_count = Arc::new(RwLock::new(0)),
            compute_count = Arc::new(RwLock::new(0)),
            governance_count = Arc::new(RwLock::new(0)),
            rejected_count = Arc::new(RwLock::new(0)),
            private_count = Arc::new(RwLock::new(0)),
        }
    }

    /// Add tx to mempool (dedup + push)
    pub fn add(&self, tx TxEnvelope) effects(io, panic, alloc) Result[String] {
        txid = tx.compute_txid()?
        txid_hex = txid.to_hex()

        // === DEDUPLICATION BY TXID ===
        {
            if self.map.read().contains_key(&txid_hex) {
                *self.rejected_count.write() += 1
                anyhow::bail("tx already in mempool (duplicate txid)")
            }
        }

        // === DEDUPLICATION BY (SENDER, NONCE) ===
        sender_opt = tx.payload.get_sender().or_else(|| tx.sender_address().ok().flatten())
        nonce_opt = tx.payload.get_nonce()
        
        if let (Some(sender), Some(nonce)) = (sender_opt, nonce_opt) {
            nonce_key = format("{}|{}", sender, nonce)
            
            if self.nonce_map.read().contains_key(&nonce_key) {
                *self.rejected_count.write() += 1
                println("‚ùå Rejected: duplicate (sender, nonce) = ({}, {})", sender, nonce)
                anyhow::bail("tx with same sender and nonce already exists")
            }
            
            // Reserve nonce
            self.nonce_map.write().insert(nonce_key.clone(), txid_hex.clone())
        }

        // extract fee and resource_class
        fee = match &tx.payload {
            TxPayload::Transfer { fee, .. }
            | TxPayload::Stake { fee, .. }
            | TxPayload::Unstake { fee, .. }
            | TxPayload::ClaimReward { fee, .. }
            | TxPayload::StorageOperationPayment { fee, .. }
            | TxPayload::ComputeExecutionPayment { fee, .. }
            | TxPayload::ValidatorRegistration { fee, .. }
            | TxPayload::RegisterServiceNode { fee, .. }
            | TxPayload::GovernanceAction { fee, .. }
            | TxPayload::Custom { fee, .. } { *fee }
        }
        resource_class = tx.payload.resource_class()

        // === SIZE LIMITS PER RESOURCE CLASS ===
        // COMPILER BUG: const keyword detected as variable reassignment
        const MAX_TOTAL_TX usize = 30_000
        const MAX_STORAGE_TX usize = 10_000
        const MAX_COMPUTE_TX usize = 10_000

        total_count = self.len()
        if total_count >= MAX_TOTAL_TX {
            *self.rejected_count.write() += 1
            println("‚ùå Rejected: mempool full (total = {})", total_count)
            anyhow::bail("mempool full: total tx limit reached ({})", MAX_TOTAL_TX)
        }

        match resource_class {
            crate::tx::ResourceClass::Storage {
                count = *self.storage_count.read()
                if count >= MAX_STORAGE_TX {
                    *self.rejected_count.write() += 1
                    println("‚ùå Rejected: storage mempool full (count = {})", count)
                    anyhow::bail("storage mempool full (limit: {})", MAX_STORAGE_TX)
                }
            }
            crate::tx::ResourceClass::Compute {
                count = *self.compute_count.read()
                if count >= MAX_COMPUTE_TX {
                    *self.rejected_count.write() += 1
                    println("‚ùå Rejected: compute mempool full (count = {})", count)
                    anyhow::bail("compute mempool full (limit: {})", MAX_COMPUTE_TX)
                }
            }
            _ {} // Transfer & Governance tidak ada limit khusus
        }

        println("Mempool: added tx with resource_class {:?}", resource_class)

        entry = Entry::new(txid, fee, tx.clone())

        {
            self.map.write().insert(txid_hex.clone(), entry.clone())
        }
        {
            self.heap.write().push(entry)
        }

        // Increment counter per resource class
        match resource_class {
            crate::tx::ResourceClass::Transfer { *self.transfer_count.write() += 1 }
            crate::tx::ResourceClass::Storage { *self.storage_count.write() += 1 }
            crate::tx::ResourceClass::Compute { *self.compute_count.write() += 1 }
            crate::tx::ResourceClass::Governance { *self.governance_count.write() += 1 }
        }

        if tx.is_private() {
            *self.private_count.write() += 1
            println("üîí Private transaction added to mempool (will be relayed only)")
            println("   ‚ö†Ô∏è  Validator will NOT read payload details")
        }

        // Print metrics after add
        self.print_metrics()

        Ok(txid_hex)
    }

    /// Add tx from DB (used during node startup) - tidak perlu validasi ulang
    pub fn add_from_db(&self, tx TxEnvelope) effects(io, panic, alloc) Result[()]  {
        txid = tx.compute_txid()?
        txid_hex = txid.to_hex()

        // deduplicate by txid
        {
            if self.map.read().contains_key(&txid_hex) {
                return Ok(()) // skip jika sudah ada
            }
        }

        // deduplicate by (sender, nonce)
        sender_opt = tx.payload.get_sender().or_else(|| tx.sender_address().ok().flatten())
        nonce_opt = tx.payload.get_nonce()
        
        if let (Some(sender), Some(nonce)) = (sender_opt, nonce_opt) {
            nonce_key = format("{}|{}", sender, nonce)
            
            if self.nonce_map.read().contains_key(&nonce_key) {
                return Ok(()) // skip jika sudah ada
            }
            
            self.nonce_map.write().insert(nonce_key, txid_hex.clone())
        }

        // extract fee
        fee = match &tx.payload {
            TxPayload::Transfer { fee, .. }
            | TxPayload::Stake { fee, .. }
            | TxPayload::Unstake { fee, .. }
            | TxPayload::ClaimReward { fee, .. }
            | TxPayload::StorageOperationPayment { fee, .. }
            | TxPayload::ComputeExecutionPayment { fee, .. }
            | TxPayload::ValidatorRegistration { fee, .. }
            | TxPayload::RegisterServiceNode { fee, .. }
            | TxPayload::GovernanceAction { fee, .. }
            | TxPayload::Custom { fee, .. } { *fee }
        }

        entry = Entry::new(txid, fee, tx.clone())
        // COMPILER BUG: "first assigned on line 0" - this is a new variable in this scope
        mut resource_class = entry.resource_class

        {
            self.map.write().insert(txid_hex.clone(), entry.clone())
        }
        {
            self.heap.write().push(entry)
        }

        // Increment counter
        match resource_class {
            crate::tx::ResourceClass::Transfer { *self.transfer_count.write() += 1 }
            crate::tx::ResourceClass::Storage { *self.storage_count.write() += 1 }
            crate::tx::ResourceClass::Compute { *self.compute_count.write() += 1 }
            crate::tx::ResourceClass::Governance { *self.governance_count.write() += 1 }
        }

        println("Mempool: restored tx {} from DB (resource_class: {:?})", txid_hex, resource_class)
        
        if tx.is_private() {
            *self.private_count.write() += 1
            println("üîí Private transaction restored from DB (blind relay mode)")
        }

        Ok(())
    }
    
    /// Pop transaksi berdasarkan ResourceClass tertentu (untuk specialized nodes)
    /// Hanya mengambil tx yang sesuai dengan resource_class yang diminta
    pub fn pop_by_resource(&self, limit usize, rclass crate::tx::ResourceClass) effects(io, alloc) Vec[TxEnvelope] {
        mut out = Vec::with_capacity(limit)
        mut temp_storage Vec[Entry] = Vec::new()

        // Loop sampai dapat limit tx atau heap kosong
        while out.len() < limit {
            entry_opt = self.heap.write().pop()
            
            match entry_opt {
                Some(entry) {
                    // Cek apakah resource_class cocok
                    if entry.resource_class == rclass {
                        // Cocok -> ambil tx ini
                        txid_hex = entry.txid.to_hex()
                        self.map.write().remove(&txid_hex)
                        
                        // Cleanup nonce_map
                        sender_opt = entry.tx.payload.get_sender()
                            .or_else(|| entry.tx.sender_address().ok().flatten())
                        nonce_opt = entry.tx.payload.get_nonce()
                        
                        if let (Some(sender), Some(nonce)) = (sender_opt, nonce_opt) {
                            nonce_key = format("{}|{}", sender, nonce)
                            self.nonce_map.write().remove(&nonce_key)
                        }

                        // Decrement counter - FIX: avoid deadlock
                        match entry.resource_class {
                            crate::tx::ResourceClass::Transfer {
                                mut count = self.transfer_count.write()
                                *count = count.saturating_sub(1)
                            }
                            crate::tx::ResourceClass::Storage {
                                mut count = self.storage_count.write()
                                *count = count.saturating_sub(1)
                            }
                            crate::tx::ResourceClass::Compute {
                                mut count = self.compute_count.write()
                                *count = count.saturating_sub(1)
                            }
                            crate::tx::ResourceClass::Governance {
                                mut count = self.governance_count.write()
                                *count = count.saturating_sub(1)
                            }
                        }
                        
                        // Decrement private count if applicable
                        if entry.is_private {
                            mut count = self.private_count.write()
                            *count = count.saturating_sub(1)
                        }

                        out.push(entry.tx)
                    } else {
                        // Tidak cocok -> simpan sementara untuk dikembalikan
                        temp_storage.push(entry)
                    }
                }
                None { break } // Heap kosong
            }
        }

        // Kembalikan tx yang tidak cocok ke heap
        {
            mut heap = self.heap.write()
            for entry in temp_storage {
                heap.push(entry)
            }
        }

        println("üì¶ Popped {} tx(s) for resource_class {:?}", out.len(), rclass)
        out
    }

    /// Pop transaksi mixed mode (semua resource class, prioritas tertinggi)
    /// Untuk validator yang bisa handle semua jenis transaksi
    pub fn pop_mixed(&self, total_limit usize) effects(io, alloc) Vec[TxEnvelope] {
        mut out = Vec::with_capacity(total_limit.min(self.len()))

        for _ in 0..total_limit {
            entry_opt = self.heap.write().pop()
            if let Some(entry) = entry_opt {
                txid_hex = entry.txid.to_hex()
                self.map.write().remove(&txid_hex)
                
                // Cleanup nonce_map
                sender_opt = entry.tx.payload.get_sender()
                    .or_else(|| entry.tx.sender_address().ok().flatten())
                nonce_opt = entry.tx.payload.get_nonce()
                
                if let (Some(sender), Some(nonce)) = (sender_opt, nonce_opt) {
                    nonce_key = format("{}|{}", sender, nonce)
                    self.nonce_map.write().remove(&nonce_key)
                }

                // Decrement counter
                match entry.resource_class {
                    crate::tx::ResourceClass::Transfer {
                        mut count = self.transfer_count.write()
                        *count = count.saturating_sub(1)
                    }
                    crate::tx::ResourceClass::Storage {
                        mut count = self.storage_count.write()
                        *count = count.saturating_sub(1)
                    }
                    crate::tx::ResourceClass::Compute {
                        mut count = self.compute_count.write()
                        *count = count.saturating_sub(1)
                    }
                    crate::tx::ResourceClass::Governance {
                        mut count = self.governance_count.write()
                        *count = count.saturating_sub(1)
                    }
                }

                out.push(entry.tx)
            } else {
                break
            }
        }

        println("üì¶ Popped {} tx(s) in mixed mode (all resource classes)", out.len())
        out
    }

    // REAL FIX: added panic to propagate from print_metrics()
    pub fn pop_for_block(&self, limit usize) effects(io, alloc, panic) Vec[TxEnvelope] {
        result = self.pop_mixed(limit)
        
        // Print metrics after pop
        if !result.is_empty() {
            self.print_metrics()
        }
        
        result
    }

    /// Snapshot current mempool (read-only)
    // COMPILER BUG: .read() falsely detected as io effect - this is pure!
    pub fn snapshot(&self) effects(alloc) Vec[TxEnvelope] {
        self.map.read().values().map(|e| e.tx.clone()).collect()
    }

    // COMPILER BUG: .read() falsely detected as io effect - this is pure!
    pub fn len(&self) usize {
        self.map.read().len()
    }

    /// Get count of private transactions (13.7.F)
    // COMPILER BUG: .read() falsely detected as io effect - this is pure!
    pub fn private_count(&self) usize {
        *self.private_count.read()
    }

    /// Check if a tx is private by txid
    // COMPILER BUG: .read() falsely detected as io effect - this is pure!
    pub fn is_tx_private(&self, txid_hex &str) Option[bool] {
        self.map.read().get(txid_hex).map(|e| e.is_private)
    }

    /// Remove tx by txid_hex (used on reorg / expiry)
    // COMPILER BUG: .read()/.write() falsely detected as io effect
    pub fn remove(&self, txid_hex &str) effects(alloc) bool {
        if let Some(entry) = self.map.write().remove(txid_hex) {
            // Cleanup nonce_map
            sender_opt = entry.tx.payload.get_sender()
                .or_else(|| entry.tx.sender_address().ok().flatten())
            nonce_opt = entry.tx.payload.get_nonce()
            
            if let (Some(sender), Some(nonce)) = (sender_opt, nonce_opt) {
                nonce_key = format("{}|{}", sender, nonce)
                self.nonce_map.write().remove(&nonce_key)
            }

            // Decrement counter
            match entry.resource_class {
                crate::tx::ResourceClass::Transfer {
                    *self.transfer_count.write() = self.transfer_count.read().saturating_sub(1)
                }
                crate::tx::ResourceClass::Storage {
                    *self.storage_count.write() = self.storage_count.read().saturating_sub(1)
                }
                crate::tx::ResourceClass::Compute {
                    *self.compute_count.write() = self.compute_count.read().saturating_sub(1)
                }
                crate::tx::ResourceClass::Governance {
                    *self.governance_count.write() = self.governance_count.read().saturating_sub(1)
                }
            }

            // lazily rebuild heap
            mut heap = self.heap.write()
            heap.clear()
            for e in self.map.read().values() {
                heap.push(e.clone())
            }
            true
        } else {
            false
        }
    }

    pub fn print_metrics(&self) effects(io, panic) {
        total = self.len()
        transfer = *self.transfer_count.read()
        storage = *self.storage_count.read()
        compute = *self.compute_count.read()
        governance = *self.governance_count.read()
        rejected = *self.rejected_count.read()
        private = *self.private_count.read()

        // Calculate oldest tx age
        oldest_age_ms = self.map.read()
            .values()
            .map(|e| {
                now = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u128
                now.saturating_sub(e.ts)
            })
            .max()
            .unwrap_or(0)

        oldest_age_sec = oldest_age_ms / 1000

        println("üìä === MEMPOOL METRICS ===")
        println("   Total TX: {}", total)
        println("   Transfer: {}", transfer)
        println("   Storage: {} / 10000", storage)
        println("   Compute: {} / 10000", compute)
        println("   Governance: {}", governance)
        println("   üîí Private: {} (blind relay)", private)
        println("   Rejected: {}", rejected)
        println("   Oldest TX age: {}s", oldest_age_sec)
        println("========================")
    }
}


#[cfg(test)]
mod tests {
    use super::*
    use crate::tx::{TxPayload, TxEnvelope, ResourceClass}
    use crate::crypto::{generate_ed25519_keypair_bytes, sign_message_with_keypair_bytes, address_from_pubkey_bytes}

    #[test]
    fn mempool_add_pop_new_payloads() effects(io, panic, alloc) {
        (pk, kp_bytes) = generate_ed25519_keypair_bytes()
        addr = address_from_pubkey_bytes(&pk).unwrap()

        payload = TxPayload::StorageOperationPayment {
            from = addr,
            to_node = addr,
            amount = 1000,
            fee = 50,
            nonce = 0,
            operation_id = vec(1, 2, 3),
            gas_limit = 25000,
            resource_class = ResourceClass::Storage,
            metadata_flagged = false,
        }

        mut env = TxEnvelope::new_unsigned(payload)
        env.pubkey = pk.clone()
        env.is_private = false
        sig_bytes = env.payload_bytes().unwrap()
        env.signature = sign_message_with_keypair_bytes(&kp_bytes, &sig_bytes).unwrap()

        mem = Mempool::new()
        mem.add(env.clone()).unwrap()
        assert_eq(mem.len(), 1)

        txs = mem.pop_for_block(10)
        assert_eq(txs.len(), 1)
        assert_eq(mem.len(), 0)
    }

    #[test]
    fn mempool_pop_by_resource_filter() effects(io, panic, alloc) {
        (pk, kp_bytes) = generate_ed25519_keypair_bytes()
        addr = address_from_pubkey_bytes(&pk).unwrap()

        mem = Mempool::new()

        // Add Storage tx
        storage_payload = TxPayload::StorageOperationPayment {
            from = addr,
            to_node = addr,
            amount = 1000,
            fee = 50,
            nonce = 0,
            operation_id = vec(1, 2, 3),
            gas_limit = 25000,
            resource_class = ResourceClass::Storage,
            metadata_flagged = false,
        }
        mut storage_env = TxEnvelope::new_unsigned(storage_payload)
        storage_env.pubkey = pk.clone()
        storage_env.is_private = false
        sig_bytes = storage_env.payload_bytes().unwrap()
        storage_env.signature = sign_message_with_keypair_bytes(&kp_bytes, &sig_bytes).unwrap()
        mem.add(storage_env).unwrap()

        // Add Compute tx
        compute_payload = TxPayload::ComputeExecutionPayment {
            from = addr,
            to_node = addr,
            amount = 2000,
            fee = 100,
            nonce = 1,
            execution_id = vec(4, 5, 6),
            gas_limit = 40000,
            resource_class = ResourceClass::Compute,
            metadata_flagged = false,
        }
        mut compute_env = TxEnvelope::new_unsigned(compute_payload)
        compute_env.pubkey = pk.clone()
        compute_env.is_private = false
        sig_bytes2 = compute_env.payload_bytes().unwrap()
        compute_env.signature = sign_message_with_keypair_bytes(&kp_bytes, &sig_bytes2).unwrap()
        mem.add(compute_env).unwrap()

        assert_eq(mem.len(), 2)

        // Pop only Storage tx
        storage_txs = mem.pop_by_resource(10, ResourceClass::Storage)
        assert_eq(storage_txs.len(), 1)
        assert_eq(mem.len(), 1) // Compute tx masih ada

        // Pop Compute tx
        compute_txs = mem.pop_by_resource(10, ResourceClass::Compute)
        assert_eq(compute_txs.len(), 1)
        assert_eq(mem.len(), 0) // Semua sudah diambil
    }
}