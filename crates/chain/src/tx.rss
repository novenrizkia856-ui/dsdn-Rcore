//! transaction envelope, payload types and signing / id helpers
use serde::{Serialize, Deserialize};
use crate::types::{Address, Hash};
use crate::crypto::{sha3_512_bytes, address_from_pubkey_bytes, verify_signature};
use crate::receipt::{ResourceReceipt, ResourceType};
use crate::state::{ProposalType, ProposalStatus, VoteOption};
use dsdn_common::gating::NodeClass;
use anyhow::{Result, anyhow};

const MIN_GAS_LIMIT: u64 = 21000;  // base gas like EVM
pub const GAS_PRICE: u128 = 1;    // 1 wei per gas, simple (made pub for state.rs)

// === STAKE REQUIREMENTS 
pub use crate::tokenomics::{VALIDATOR_MIN_STAKE, DELEGATOR_MIN_STAKE};
// Legacy aliases
pub const MIN_VALIDATOR_STAKE: u128 = 50_000;
pub const MIN_DELEGATOR_STAKE: u128 = 100_000;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ResourceClass {
    Transfer,
    Storage,
    Compute,
    Governance,
}

/// Governance action types for TxPayload::GovernanceAction (13.12.5)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum GovernanceActionType {
    /// Create new governance proposal
    CreateProposal {
        proposal_type: ProposalType,
        title: String,
        description: String,
    },
    /// Cast vote on proposal
    CastVote {
        proposal_id: u64,
        vote: VoteOption,
    },
    /// Finalize proposal after voting period
    FinalizeProposal {
        proposal_id: u64,
    },
    /// Foundation veto (Bootstrap Mode)
    FoundationVeto {
        proposal_id: u64,
    },
    /// Foundation override result (Bootstrap Mode)
    FoundationOverride {
        proposal_id: u64,
        new_status: ProposalStatus,
    },
}

/// Payload variants for transactions
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub enum TxPayload {
    /// Transfer from -> to
    Transfer {
        from: Address,
        to: Address,
        amount: u128,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Stake operations (Bond/Unbond)
    Stake {
        delegator: Address,
        validator: Address,
        amount: u128,
        fee: u128,
        nonce: u64,
        bond: bool,  // true = bond, false = unbond
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Unstake (separate for clarity, but can merge with Stake bond=false)
    Unstake {
        delegator: Address,
        validator: Address,
        amount: u128,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Claim rewards
    ClaimReward {
        receipt: ResourceReceipt,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
    },

    /// Payment for storage operations (DSDN upload chunk, etc.)
    StorageOperationPayment {
        from: Address,
        to_node: Address,
        amount: u128,
        fee: u128,
        nonce: u64,
        operation_id: Vec<u8>,  // chunk hash or id
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Payment for compute execution (DSDN WASM/microVM run)
    ComputeExecutionPayment {
        from: Address,
        to_node: Address,
        amount: u128,
        fee: u128,
        nonce: u64,
        execution_id: Vec<u8>,  // job id
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Register as validator
    ValidatorRegistration {
        from: Address,
        pubkey: Vec<u8>,
        min_stake: u128,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Governance action (stub)
    GovernanceAction {
        from: Address,
        action: GovernanceActionType,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
    },

    /// Register service node (DSDN storage/compute node)
    RegisterServiceNode {
        from: Address,
        node_id: Vec<u8>,
        class: NodeClass,  // NodeClass from dsdn_common
        tls_fingerprint: Vec<u8>,
        identity_proof_sig: Vec<u8>,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },

    /// Custom for expansion
    Custom {
        call_type: String,
        payload: Vec<u8>,
        fee: u128,
        nonce: u64,
        gas_limit: u64,
        resource_class: ResourceClass,
        metadata_flagged: bool,
    },
}

#[derive(Debug, Clone)]
pub struct PrivateTxInfo {
    pub sender: Address,
    pub fee: u128,
    pub gas_limit: u64,
    pub nonce: u64,
    pub resource_class: ResourceClass,
}

/// Envelope holding payload + signer pubkey + signature
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TxEnvelope {
    pub payload: TxPayload,
    pub pubkey: Vec<u8>,
    pub signature: Vec<u8>,
    pub is_private: bool,
    #[serde(skip)]
    pub cached_id: Option<Hash>,
}

impl TxEnvelope {
    pub fn new_unsigned(payload: TxPayload) -> Self {
        Self {
            payload,
            pubkey: Vec::new(),
            signature: Vec::new(),
            is_private: false,
            cached_id: None,
        }
    }

    pub fn payload_bytes(&self) -> Result<Vec<u8>> {
        bincode::serialize(&self.payload).map_err(Into::into)
    }

    pub fn sign_input_bytes(&self) -> Result<Vec<u8>> {
        let mut out = Vec::new();
        out.extend_from_slice(&bincode::serialize(&self.payload)?);
        out.extend_from_slice(&self.pubkey);
        Ok(out)
    }

    pub fn compute_txid(&self) -> Result<Hash> {
        let mut buf = Vec::new();
        buf.extend_from_slice(&bincode::serialize(&self.payload)?);
        buf.extend_from_slice(&self.pubkey);
        buf.extend_from_slice(&self.signature);
        Ok(Hash::from_bytes(sha3_512_bytes(&buf)))
    }

    pub fn txid_hex(&self) -> Result<String> {
        Ok(self.compute_txid()?.to_hex())
    }

    pub fn verify_signature(&self) -> Result<bool> {
        if self.pubkey.is_empty() || self.signature.is_empty() {
            return Ok(false);
        }
        let payload_bytes = self.payload_bytes()?;
        verify_signature(&self.pubkey, &payload_bytes, &self.signature)
    }

    pub fn sender_address(&self) -> Result<Option<Address>> {
        if self.pubkey.is_empty() {
            return Ok(None);
        }
        address_from_pubkey_bytes(&self.pubkey).map(Some)
    }

    pub fn is_private(&self) -> bool {
        self.is_private
    }

    pub fn validate_stateless(&self) -> Result<()> {
        if !self.verify_signature()? {
            return Err(anyhow!("invalid signature"));
        }
        let sender = self.sender_address()?.ok_or(anyhow!("no sender"))?;
        
        // Validate payload-specific fields
        match &self.payload {
            TxPayload::Transfer { from, gas_limit, .. } => {
                if from != &sender {
                    return Err(anyhow!("from address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::Stake { delegator, gas_limit, .. } => {
                if delegator != &sender {
                    return Err(anyhow!("delegator address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::Unstake { delegator, gas_limit, .. } => {
                if delegator != &sender {
                    return Err(anyhow!("delegator address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::StorageOperationPayment { from, gas_limit, .. } => {
                if from != &sender {
                    return Err(anyhow!("from address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::ComputeExecutionPayment { from, gas_limit, .. } => {
                if from != &sender {
                    return Err(anyhow!("from address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::ValidatorRegistration { from, gas_limit, .. } => {
                if from != &sender {
                    return Err(anyhow!("from address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::RegisterServiceNode { from, gas_limit, .. } => {
                if from != &sender {
                    return Err(anyhow!("from address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::GovernanceAction { from, gas_limit, .. } => {
                if from != &sender {
                    return Err(anyhow!("from address mismatch"));
                }
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::ClaimReward { gas_limit, .. } => {
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
            TxPayload::Custom { gas_limit, .. } => {
                if *gas_limit < MIN_GAS_LIMIT {
                    return Err(anyhow!("gas limit too low"));
                }
            }
        }
        Ok(())
    }

    pub fn validate_stateful<F1, F2>(&self, get_balance: F1, get_nonce: F2) -> Result<()>
    where
        F1: Fn(&Address) -> u128,
        F2: Fn(&Address) -> u64,
    {
        let sender = self.sender_address()?.ok_or(anyhow!("no sender"))?;
        
        match &self.payload {
            TxPayload::Transfer { from, amount, fee, nonce, .. } => {
                let balance = get_balance(from);
                let total_cost = amount + fee;
                if balance < total_cost {
                    return Err(anyhow!("insufficient balance: {} < {}", balance, total_cost));
                }
                let expected_nonce = get_nonce(from);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::Stake { delegator, amount, fee, nonce, .. } => {
                let balance = get_balance(delegator);
                let total_cost = amount + fee;
                if balance < total_cost {
                    return Err(anyhow!("insufficient balance: {} < {}", balance, total_cost));
                }
                let expected_nonce = get_nonce(delegator);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::Unstake { delegator, fee, nonce, .. } => {
                let balance = get_balance(delegator);
                if balance < *fee {
                    return Err(anyhow!("insufficient balance for fee: {} < {}", balance, fee));
                }
                let expected_nonce = get_nonce(delegator);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::StorageOperationPayment { from, amount, fee, nonce, .. } => {
                let balance = get_balance(from);
                let total_cost = amount + fee;
                if balance < total_cost {
                    return Err(anyhow!("insufficient balance: {} < {}", balance, total_cost));
                }
                let expected_nonce = get_nonce(from);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::ComputeExecutionPayment { from, amount, fee, nonce, .. } => {
                let balance = get_balance(from);
                let total_cost = amount + fee;
                if balance < total_cost {
                    return Err(anyhow!("insufficient balance: {} < {}", balance, total_cost));
                }
                let expected_nonce = get_nonce(from);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::ValidatorRegistration { from, min_stake, fee, nonce, .. } => {
                let balance = get_balance(from);
                let total_cost = min_stake + fee;
                if balance < total_cost {
                    return Err(anyhow!("insufficient balance: {} < {}", balance, total_cost));
                }
                let expected_nonce = get_nonce(from);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::RegisterServiceNode { from, fee, nonce, .. } => {
                let balance = get_balance(from);
                if balance < *fee {
                    return Err(anyhow!("insufficient balance for fee: {} < {}", balance, fee));
                }
                let expected_nonce = get_nonce(from);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::GovernanceAction { from, fee, nonce, .. } => {
                let balance = get_balance(from);
                if balance < *fee {
                    return Err(anyhow!("insufficient balance for fee: {} < {}", balance, fee));
                }
                let expected_nonce = get_nonce(from);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::ClaimReward { nonce, .. } => {
                let expected_nonce = get_nonce(&sender);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
            TxPayload::Custom { fee, nonce, .. } => {
                let balance = get_balance(&sender);
                if balance < *fee {
                    return Err(anyhow!("insufficient balance for fee: {} < {}", balance, fee));
                }
                let expected_nonce = get_nonce(&sender);
                if *nonce != expected_nonce {
                    return Err(anyhow!("nonce mismatch: {} != {}", nonce, expected_nonce));
                }
            }
        }
        Ok(())
    }
}

impl TxPayload {
    pub fn resource_class(&self) -> ResourceClass {
        match self {
            TxPayload::Transfer { resource_class, .. }
            | TxPayload::Stake { resource_class, .. }
            | TxPayload::Unstake { resource_class, .. }
            | TxPayload::StorageOperationPayment { resource_class, .. }
            | TxPayload::ComputeExecutionPayment { resource_class, .. }
            | TxPayload::ValidatorRegistration { resource_class, .. }
            | TxPayload::RegisterServiceNode { resource_class, .. }
            | TxPayload::Custom { resource_class, .. } => *resource_class,
            TxPayload::GovernanceAction { .. } => ResourceClass::Governance,
            TxPayload::ClaimReward { .. } => ResourceClass::Transfer,
        }
    }

    pub fn is_flagged_illegal(&self) -> bool {
        match self {
            TxPayload::Transfer { metadata_flagged, .. }
            | TxPayload::Stake { metadata_flagged, .. }
            | TxPayload::Unstake { metadata_flagged, .. }
            | TxPayload::StorageOperationPayment { metadata_flagged, .. }
            | TxPayload::ComputeExecutionPayment { metadata_flagged, .. }
            | TxPayload::ValidatorRegistration { metadata_flagged, .. }
            | TxPayload::RegisterServiceNode { metadata_flagged, .. }
            | TxPayload::Custom { metadata_flagged, .. } => *metadata_flagged,
            TxPayload::GovernanceAction { .. } => false,
            TxPayload::ClaimReward { .. } => false,
        }
    }

    /// Extract nonce from payload (for mempool deduplication)
    pub fn get_nonce(&self) -> Option<u64> {
        match self {
            TxPayload::Transfer { nonce, .. }
            | TxPayload::Stake { nonce, .. }
            | TxPayload::Unstake { nonce, .. }
            | TxPayload::ClaimReward { nonce, .. }
            | TxPayload::StorageOperationPayment { nonce, .. }
            | TxPayload::ComputeExecutionPayment { nonce, .. }
            | TxPayload::ValidatorRegistration { nonce, .. }
            | TxPayload::RegisterServiceNode { nonce, .. }
            | TxPayload::GovernanceAction { nonce, .. }
            | TxPayload::Custom { nonce, .. } => Some(*nonce),
        }
    }

    /// Extract sender address from payload (for mempool deduplication)
    pub fn get_sender(&self) -> Option<Address> {
        match self {
            TxPayload::Transfer { from, .. } => Some(*from),
            TxPayload::Stake { delegator, .. } => Some(*delegator),
            TxPayload::Unstake { delegator, .. } => Some(*delegator),
            TxPayload::ClaimReward { receipt, .. } => Some(receipt.node_address),
            TxPayload::StorageOperationPayment { from, .. } => Some(*from),
            TxPayload::ComputeExecutionPayment { from, .. } => Some(*from),
            TxPayload::ValidatorRegistration { from, .. } => Some(*from),
            TxPayload::RegisterServiceNode { from, .. } => Some(*from),
            TxPayload::GovernanceAction { from, .. } => Some(*from),
            TxPayload::Custom { .. } => None,
        }
    }

    /// Validate stake requirements sebelum tx masuk mempool (13.7.C + 13.8.A + 13.8.B)
    /// Returns Ok(()) jika valid, Err jika tidak memenuhi minimum stake
    pub fn validate_stake_requirements(&self) -> Result<()> {
        match self {
            TxPayload::Stake { amount, bond, .. } => {
                // Hanya cek untuk bond operation
                if *bond {
                    // Check minimum stake
                    if *amount < crate::tokenomics::DELEGATOR_MIN_STAKE {
                        return Err(anyhow!(
                            "stake below minimum: {} < {}",
                            amount,
                            crate::tokenomics::DELEGATOR_MIN_STAKE
                        ));
                    }
                }
                Ok(())
            }
            TxPayload::ValidatorRegistration { min_stake, .. } => {
                // Use tokenomics constant (13.8.A)
                if *min_stake < crate::tokenomics::VALIDATOR_MIN_STAKE {
                    return Err(anyhow!(
                        "validator stake below minimum: {} < {}",
                        min_stake,
                        crate::tokenomics::VALIDATOR_MIN_STAKE
                    ));
                }
                Ok(())
            }
            // Payload lain tidak memerlukan stake validation
            _ => Ok(()),
        }
    }

    /// Check if this transaction type allows validator to receive fees (13.8.A)
    /// Compute/Storage transactions do NOT pay fees to validators
    pub fn is_validator_fee_eligible(&self) -> bool {
        crate::tokenomics::is_validator_fee_eligible(&self.resource_class())
    }

    // ============================================================
    // DELEGATION HELPERS (13.8.B)
    // ============================================================

    /// Check if this is a self-delegation (validator staking to themselves)
    /// vs external delegation (delegator staking to validator)
    pub fn is_self_delegation(&self) -> bool {
        match self {
            TxPayload::Stake { delegator, validator, .. } => delegator == validator,
            _ => false,
        }
    }

    /// Check if this is an external delegation (delegator != validator)
    pub fn is_external_delegation(&self) -> bool {
        match self {
            TxPayload::Stake { delegator, validator, bond, .. } => {
                *bond && delegator != validator
            }
            _ => false,
        }
    }

    /// Get delegation info (delegator, validator) if this is a stake tx
    pub fn get_delegation_info(&self) -> Option<(Address, Address)> {
        match self {
            TxPayload::Stake { delegator, validator, .. } => Some((*delegator, *validator)),
            TxPayload::Unstake { delegator, validator, .. } => Some((*delegator, *validator)),
            _ => None,
        }
    }

    // ============================================================
    // QV HELPERS (13.8.C)
    // ============================================================

    /// Get stake amount from payload (for QV calculation)
    pub fn get_stake_amount(&self) -> Option<u128> {
        match self {
            TxPayload::Stake { amount, .. } => Some(*amount),
            TxPayload::Unstake { amount, .. } => Some(*amount),
            TxPayload::ValidatorRegistration { min_stake, .. } => Some(*min_stake),
            _ => None,
        }
    }

    /// Check if this transaction affects QV weights
    /// Returns true for stake-related transactions
    pub fn affects_qv_weight(&self) -> bool {
        matches!(
            self,
            TxPayload::Stake { .. } 
            | TxPayload::Unstake { .. } 
            | TxPayload::ValidatorRegistration { .. }
        )
    }

    /// Get addresses that need QV weight update after this transaction
    /// Returns (primary_addr, optional_validator_addr)
    pub fn get_qv_update_addresses(&self) -> Option<(Address, Option<Address>)> {
        match self {
            TxPayload::Stake { delegator, validator, .. } => {
                Some((*delegator, Some(*validator)))
            }
            TxPayload::Unstake { delegator, validator, .. } => {
                Some((*delegator, Some(*validator)))
            }
            TxPayload::ValidatorRegistration { from, .. } => {
                Some((*from, Some(*from)))  // validator is same as from
            }
            _ => None,
        }
    }

    // ============================================================
    // Private TX Helpers (13.7.F) - Extract minimal info only
    // ============================================================

    /// Extract minimal info required for blind validation (fee, gas_limit, nonce)
    /// Validator hanya boleh mengakses info ini untuk private tx
    pub fn get_blind_info(&self) -> (u128, u64, u64) {
        match self {
            TxPayload::Transfer { fee, gas_limit, nonce, .. }
            | TxPayload::Stake { fee, gas_limit, nonce, .. }
            | TxPayload::Unstake { fee, gas_limit, nonce, .. }
            | TxPayload::ClaimReward { fee, gas_limit, nonce, .. }
            | TxPayload::StorageOperationPayment { fee, gas_limit, nonce, .. }
            | TxPayload::ComputeExecutionPayment { fee, gas_limit, nonce, .. }
            | TxPayload::ValidatorRegistration { fee, gas_limit, nonce, .. }
            | TxPayload::RegisterServiceNode { fee, gas_limit, nonce, .. }
            | TxPayload::GovernanceAction { fee, gas_limit, nonce, .. }
            | TxPayload::Custom { fee, gas_limit, nonce, .. } => (*fee, *gas_limit, *nonce),
        }
    }

    /// Get fee only (safe for private tx)
    pub fn get_fee(&self) -> u128 {
        self.get_blind_info().0
    }

    /// Get gas_limit only (safe for private tx)
    pub fn get_gas_limit(&self) -> u64 {
        self.get_blind_info().1
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::{generate_ed25519_keypair_bytes, address_from_pubkey_bytes};
    use crate::state::ChainState;

    #[test]
    fn test_transfer_sign_verify_and_stateful_validate() {
        let (pk, kp_bytes) = generate_ed25519_keypair_bytes();
        let from_addr = address_from_pubkey_bytes(&pk).expect("addr");
        let to_addr = Address::from_bytes([0x22u8; 20]);
        let payload = TxPayload::Transfer {
            from: from_addr,
            to: to_addr,
            amount: 1_000,
            fee: 10,
            nonce: 1,
            gas_limit: 21000,
            resource_class: ResourceClass::Transfer,
            metadata_flagged: false,
        };
        let mut env = TxEnvelope::new_unsigned(payload.clone());
        env.pubkey = pk.clone();
        env.is_private = false;
        let payload_bytes = env.payload_bytes().expect("payload bytes");
        let sig = crate::crypto::sign_message_with_keypair_bytes(&kp_bytes, &payload_bytes).expect("sign");
        env.signature = sig;
        env.validate_stateless().expect("stateless ok");
        let mut st = ChainState::new();
        st.create_account(from_addr);
        st.create_account(to_addr);
        st.mint(&from_addr, 50_000).expect("mint");  // cukup untuk gas + fee + amount
        let get_balance = |a: &Address| st.get_balance(a);
        let get_nonce = |_a: &Address| -> u64 { 0u64 };
        env.validate_stateful(get_balance, get_nonce).expect("stateful ok");
    }
}