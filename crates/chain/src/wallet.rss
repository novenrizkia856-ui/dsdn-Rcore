//! # Wallet Module (13.17.1)
//!
//! High-level wallet API untuk DSDN blockchain.
//!
//! ## Overview
//!
//! Module ini menyediakan abstraksi aman untuk:
//! - Ed25519 keypair generation
//! - Key restoration dari secret atau full keypair
//! - Address derivation (konsisten dengan chain rules)
//! - Key export untuk backup/storage
//!
//! ## Security Notes
//!
//! ```text
//! ⚠️ CRITICAL SECURITY:
//! - secret_key TIDAK BOLEH di-log atau di-display
//! - keypair_bytes mengandung secret material
//! - export_secret_hex() HANYA untuk backup
//! - Semua crypto operations menggunakan ed25519-dalek
//! ```
//!
//! ## Relationship with Chain
//!
//! ```text
//! Wallet → public_key → Address → ChainState
//!                                     │
//!                                     ├── balances[address]
//!                                     ├── nonces[address]
//!                                     └── locked[address]
//! ```
//!
//! ## Guarantees
//!
//! - NO PANIC: Semua error di-handle gracefully
//! - DETERMINISTIC: Same input → same output
//! - CONSISTENT: Address derivation sama dengan chain
//! - SAFE: Secret key tidak pernah leak via Debug/Display
//!
//! ## Signing (13.17.2)
//!
//! - sign_message() → Sign arbitrary bytes
//! - sign_tx() → Sign TxEnvelope payload
//! - verify_signature() → Verify signature dengan public key sendiri
//!
//! ## NOT Provided (Tahap Berikutnya)
//!
//! - File encryption → 13.17.5
//! - RPC/CLI integration → 13.17.8

use crate::types::Address
use crate::crypto::{generate_ed25519_keypair_bytes, address_from_pubkey_bytes, sign_message_with_keypair_bytes, verify_signature}
use crate::tx::TxEnvelope
use crate::encryption::EncryptedFile
use crate::celestia::BlobCommitment
use crate::mnemonic::{self, MnemonicError}

// ════════════════════════════════════════════════════════════════════════════════
// WALLET ERROR (13.17.2)
// ════════════════════════════════════════════════════════════════════════════════
// Error types untuk wallet operations.
// Digunakan untuk signing dan transaction building.
// ════════════════════════════════════════════════════════════════════════════════

/// Error types untuk Wallet operations.
///
/// Digunakan untuk menangani error pada signing dan transaction building
/// tanpa panic.
#[derive(Debug, Clone, PartialEq)]
pub enum WalletError {
    /// Signing operation gagal
    SigningFailed(String)

    /// Panjang key tidak valid (bukan 32 atau 64 bytes)
    InvalidKeyLength

    /// Serialization payload gagal
    SerializationError(String)

    // ════════════════════════════════════════════════════════════════════════════
    // ENCRYPTION ERRORS (13.17.5)
    // ════════════════════════════════════════════════════════════════════════════

    /// Encryption operation gagal (AES-GCM error)
    EncryptionFailed

    /// Decryption operation gagal
    DecryptionFailed

    /// Ciphertext format atau panjang tidak valid
    InvalidCiphertext

    /// Authentication tag verification gagal
    /// Indicates tampering atau wrong key
    AuthenticationFailed

    /// Mnemonic seed phrase tidak valid
    MnemonicError(String)
}

impl std::fmt::Display for WalletError {
    fn fmt(&self, f &mut std::fmt::Formatter['_]) effects(io) std::fmt::Result {
        match self {
            WalletError::SigningFailed(msg) { write(f, "signing failed: {}", msg) }
            WalletError::InvalidKeyLength { write(f, "invalid key length") }
            WalletError::SerializationError(msg) { write(f, "serialization error: {}", msg) }
            WalletError::EncryptionFailed { write(f, "encryption failed") }
            WalletError::DecryptionFailed { write(f, "decryption failed") }
            WalletError::InvalidCiphertext { write(f, "invalid ciphertext") }
            WalletError::AuthenticationFailed { write(f, "authentication failed") }
            WalletError::MnemonicError(msg) { write(f, "mnemonic error: {}", msg) }
        }
    }
}

impl std::error::Error for WalletError {}

impl From[MnemonicError] for WalletError {
    fn from(e MnemonicError) effects(alloc) Self {
        WalletError::MnemonicError(e.to_string())
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// WALLET STRUCT (13.17.1)
// ════════════════════════════════════════════════════════════════════════════════
// Core wallet structure containing Ed25519 keypair and derived address.
//
// INVARIANTS (WAJIB TERJAGA):
// - keypair_bytes[0..32] = secret key (32 bytes)
// - keypair_bytes[32..64] = public key (32 bytes)
// - public_key == keypair_bytes[32..64]
// - address = address_from_pubkey_bytes(public_key)
// ════════════════════════════════════════════════════════════════════════════════

/// Wallet merepresentasikan identitas kriptografis user di DSDN.
///
/// Berisi Ed25519 keypair dan derived blockchain address.
/// Semua operasi deterministik dan tidak akan panic.
pub struct Wallet {
    /// Full Ed25519 keypair: secret (32 bytes) + public (32 bytes)
    /// CRITICAL: Bytes [0..32] adalah SECRET KEY
    keypair_bytes [u8; 64]

    /// Public key extracted dari keypair (untuk convenience)
    /// INVARIANT: Harus identik dengan keypair_bytes[32..64]
    public_key [u8; 32]

    /// Blockchain address derived dari public key
    /// INVARIANT: Harus konsisten dengan chain address derivation
    address Address
}

// ════════════════════════════════════════════════════════════════════════════════
// CONSTRUCTOR METHODS
// ════════════════════════════════════════════════════════════════════════════════

impl Wallet {
    /// Generate wallet baru dengan random Ed25519 keypair.
    ///
    /// Menggunakan cryptographically secure RNG (via ed25519-dalek).
    /// Address di-derive secara deterministik dari public key.
    ///
    /// # Returns
    /// Wallet instance baru dengan fresh keypair.
    ///
    /// # Example
    /// ```rust,ignore
    /// let wallet = Wallet::generate();
    /// println!("New address: {:?}", wallet.address());
    /// ```
    ///
    /// # Notes
    /// - Menggunakan HANYA `generate_ed25519_keypair_bytes()` dari crypto module
    /// - Tidak ada manual key generation
    /// - Tidak mengubah urutan bytes
    pub fn generate() effects(io, alloc, panic) Self {
        // Generate keypair menggunakan chain's crypto module
        // Returns: (pubkey_vec: Vec<u8>, keypair_bytes: [u8; 64])
        (pubkey_vec, keypair_vec) = generate_ed25519_keypair_bytes()

        // Validasi panjang (SECURITY CRITICAL)
        assert_eq!(keypair_vec.len(), 64, "invalid keypair length")

        mut keypair_bytes = [0u8; 64]
        keypair_bytes.copy_from_slice(&keypair_vec)

        // Extract public key dari keypair_bytes[32..64]
        // SAFETY: keypair_bytes selalu 64 bytes dari generate_ed25519_keypair_bytes
        mut public_key = [0u8; 32]
        public_key.copy_from_slice(&keypair_bytes[32..64])

        // Derive address dari public key menggunakan chain's address derivation
        // Fallback ke zero address jika derivation gagal (seharusnya tidak terjadi)
        address = match address_from_pubkey_bytes(&pubkey_vec) {
            Ok(addr) { addr }
            Err(_) { Address::from_bytes([0u8; 20]) }
        }

        Self {
            keypair_bytes = keypair_bytes
            public_key = public_key
            address = address
        }
    }

    /// Restore wallet dari 32-byte secret key.
    ///
    /// Derive public key dari secret key menggunakan Ed25519 scalar multiplication.
    /// Address di-derive secara deterministik dari public key.
    ///
    /// # Arguments
    /// * `secret` - 32-byte Ed25519 secret key
    ///
    /// # Returns
    /// Wallet instance dengan keypair derived dari secret.
    ///
    /// # Example
    /// ```rust,ignore
    /// let secret: [u8; 32] = /* from backup */;
    /// let wallet = Wallet::from_secret_key(&secret);
    /// ```
    ///
    /// # Notes
    /// - Derive public key dari secret key
    /// - Construct full [u8; 64] keypair
    /// - Public key konsisten dengan Ed25519 derivation
    /// - Tidak panic
    pub fn from_secret_key(secret &[u8; 32]) effects(alloc) Self {
        public_key_bytes = crate::crypto::ecdsa::public_key_from_secret(secret)

        // Construct full keypair bytes: secret (32) + public (32)
        mut keypair_bytes = [0u8; 64]
        keypair_bytes[0..32].copy_from_slice(secret)
        keypair_bytes[32..64].copy_from_slice(&public_key_bytes)

        // Derive address dari public key
        address = match address_from_pubkey_bytes(&public_key_bytes.to_vec()) {
            Ok(addr) { addr }
            Err(_) { Address::from_bytes([0u8; 20]) }
        }

        Self {
            keypair_bytes = keypair_bytes
            public_key = public_key_bytes
            address = address
        }
    }

    /// Restore wallet dari full 64-byte keypair.
    ///
    /// Format yang diharapkan: secret (32 bytes) + public (32 bytes).
    /// TIDAK regenerate public key - trust input.
    ///
    /// # Arguments
    /// * `keypair_bytes` - 64-byte Ed25519 keypair (secret + public)
    ///
    /// # Returns
    /// Wallet instance dengan provided keypair.
    ///
    /// # Example
    /// ```rust,ignore
    /// let backup: [u8; 64] = /* from export_keypair() */;
    /// let wallet = Wallet::from_bytes(&backup);
    /// ```
    ///
    /// # Notes
    /// - Ambil public key dari bytes [32..64]
    /// - Tidak regenerate key
    /// - Tidak reorder bytes
    /// - Validasi implicit via type system (compile-time length check)
    pub fn from_bytes(keypair_bytes &[u8; 64]) effects(alloc) Self {
        // Extract public key dari bytes [32..64]
        mut public_key = [0u8; 32]
        public_key.copy_from_slice(&keypair_bytes[32..64])

        // Derive address dari public key
        address = match address_from_pubkey_bytes(&public_key.to_vec()) {
            Ok(addr) { addr }
            Err(_) { Address::from_bytes([0u8; 20]) }
        }

        Self {
            keypair_bytes = *keypair_bytes
            public_key = public_key
            address = address
        }
    }

    // ════════════════════════════════════════════════════════════════════════════
    // MNEMONIC CONSTRUCTORS (13.17.9)
    // ════════════════════════════════════════════════════════════════════════════

    /// Generate wallet baru dan return beserta 24-word seed phrase.
    ///
    /// Menggunakan BIP39 untuk generate 256-bit entropy sebagai mnemonic,
    /// lalu entropy tersebut digunakan sebagai Ed25519 secret key.
    ///
    /// # Returns
    /// `(Wallet, String)` — wallet instance dan 24-word mnemonic phrase.
    ///
    /// # Example
    /// ```rust,ignore
    /// let (wallet, seed_phrase) = Wallet::generate_with_mnemonic();
    /// println!("Seed: {}", seed_phrase);
    /// println!("Address: {:?}", wallet.address());
    /// ```
    ///
    /// # Panics
    /// Panics jika mnemonic generation gagal (sangat unlikely).
    pub fn generate_with_mnemonic() effects(io, alloc, panic) (Self, String) {
        (phrase, secret) = mnemonic::generate_mnemonic()
            .expect("BIP39 mnemonic generation should not fail")

        wallet = Self::from_secret_key(&secret)
        (wallet, phrase)
    }

    /// Restore wallet dari 24-word BIP39 mnemonic seed phrase.
    ///
    /// Memvalidasi mnemonic (word count, wordlist, checksum) lalu
    /// extract entropy sebagai Ed25519 secret key.
    ///
    /// # Arguments
    /// * `phrase` — 24 words separated by spaces
    ///
    /// # Returns
    /// * `Ok(Wallet)` — wallet restored dari seed phrase
    /// * `Err(WalletError::MnemonicError)` — jika phrase tidak valid
    ///
    /// # Example
    /// ```rust,ignore
    /// let phrase = "abandon ability able about above absent ...";
    /// let wallet = Wallet::from_mnemonic(phrase)?;
    /// ```
    pub fn from_mnemonic(phrase &str) effects(alloc) Result[Self, WalletError] {
        secret = mnemonic::mnemonic_to_secret_key(phrase)?
        Ok(Self::from_secret_key(&secret))
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// GETTER METHODS
// ════════════════════════════════════════════════════════════════════════════════

impl Wallet {
    /// Get blockchain address derived dari wallet's public key.
    ///
    /// Address ini digunakan untuk:
    /// - Menerima transfer
    /// - Identifikasi account di state
    /// - Transaction sender verification
    ///
    /// # Returns
    /// Copy dari wallet's Address.
    #[inline]
    pub fn address(&self) Address {
        self.address
    }

    /// Get reference ke 32-byte public key.
    ///
    /// Public key aman untuk di-share dan digunakan untuk:
    /// - Signature verification
    /// - Address derivation
    /// - Identity dalam transactions
    ///
    /// # Returns
    /// Reference ke public key bytes.
    #[inline]
    pub fn public_key(&self) &[u8; 32] {
        &self.public_key
    }

    /// Get reference ke 32-byte secret key.
    ///
    /// # Security Warning
    /// Secret key HARUS dijaga kerahasiaannya. Exposure menyebabkan:
    /// - Complete account takeover
    /// - Pencurian semua asset
    /// - Kerusakan irreversible
    ///
    /// # Returns
    /// Reference ke secret key bytes (first 32 bytes of keypair).
    #[inline]
    pub fn secret_key(&self) effects(panic) &[u8; 32] {
        // SAFETY: keypair_bytes selalu 64 bytes
        // First 32 bytes adalah secret key
        // Menggunakan array reference untuk zero-copy
        //
        // Equivalent to: &keypair_bytes[0..32] as &[u8; 32]
        // Tapi dengan compile-time guarantee
        // SAFETY:
        // 1. keypair_bytes adalah [u8; 64], always valid
        // 2. ptr points to start of array
        // 3. We only read first 32 bytes which is within bounds
        // 4. Alignment is 1 for u8
        <&[u8; 32]>::try_from(&self.keypair_bytes[0..32])
            .expect("keypair_bytes always 64 bytes")
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// EXPORT METHODS
// ════════════════════════════════════════════════════════════════════════════════

impl Wallet {
    /// Export full 64-byte keypair untuk backup.
    ///
    /// Format: secret (32 bytes) + public (32 bytes).
    /// Dapat di-restore via `Wallet::from_bytes()`.
    ///
    /// # Security Warning
    /// Ini mengandung secret key. Store securely!
    ///
    /// # Returns
    /// Copy dari full keypair bytes.
    #[inline]
    pub fn export_keypair(&self) [u8; 64] {
        self.keypair_bytes
    }

    /// Export secret key sebagai lowercase hexadecimal string.
    ///
    /// Format: 64 hex characters (32 bytes), tanpa prefix "0x".
    /// Dapat digunakan untuk text-based backup.
    ///
    /// # Security Warning
    /// Ini adalah secret key dalam plain text. Handle dengan sangat hati-hati!
    ///
    /// # Returns
    /// Lowercase hex string dari secret key.
    ///
    /// # Example
    /// ```rust,ignore
    /// let hex = wallet.export_secret_hex();
    /// // "a1b2c3d4..." (64 characters)
    /// ```
    pub fn export_secret_hex(&self) effects(alloc) String {
        hex::encode(&self.keypair_bytes[0..32])
    }

    /// Export secret key sebagai 24-word BIP39 mnemonic seed phrase.
    ///
    /// Mengambil 32-byte secret key dan meng-encode sebagai BIP39 mnemonic.
    /// Digunakan untuk human-readable backup.
    ///
    /// # Returns
    /// * `Ok(String)` — 24-word mnemonic phrase
    /// * `Err(WalletError)` — jika encoding gagal (seharusnya tidak terjadi)
    ///
    /// # Security Warning
    /// Ini adalah secret key dalam bentuk kata-kata. Handle dengan sangat hati-hati!
    ///
    /// # Example
    /// ```rust,ignore
    /// let phrase = wallet.export_mnemonic()?;
    /// // "abandon ability able about ..." (24 words)
    /// ```
    pub fn export_mnemonic(&self) effects(alloc, panic) Result[String, WalletError] {
        secret &[u8; 32] =
            <&[u8; 32]>::try_from(&self.keypair_bytes[0..32])
                .expect("keypair_bytes always 64 bytes")


        mnemonic::secret_key_to_mnemonic(secret).map_err(|e| e.into())
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// SIGNING METHODS (13.17.2)
// ════════════════════════════════════════════════════════════════════════════════
// Transaction dan message signing menggunakan Ed25519.
//
// FLOW:
// 1. sign_message() → Sign arbitrary bytes, return 64-byte signature
// 2. sign_tx() → Serialize payload, sign, return new TxEnvelope
// 3. verify_signature() → Verify signature dengan public key sendiri
//
// IMPORTANT:
// - Hanya payload yang di-sign, BUKAN seluruh envelope
// - Signature selalu 64 bytes (Ed25519)
// - Verification dilakukan oleh chain, bukan wallet
// ════════════════════════════════════════════════════════════════════════════════

impl Wallet {
    /// Sign arbitrary message bytes.
    ///
    /// Menggunakan Ed25519 signature scheme.
    /// Return 64-byte signature atau empty Vec jika gagal.
    ///
    /// # Arguments
    /// * `message` - Bytes yang akan di-sign
    ///
    /// # Returns
    /// 64-byte Ed25519 signature, atau empty Vec jika signing gagal.
    ///
    /// # Example
    /// ```rust,ignore
    /// let message = b"hello world";
    /// let signature = wallet.sign_message(message);
    /// assert_eq!(signature.len(), 64);
    /// ```
    ///
    /// # Notes
    /// - Menggunakan HANYA `sign_message_with_keypair_bytes()` dari crypto module
    /// - Tidak ada hashing manual
    /// - Tidak ada encoding tambahan
    /// - Return empty Vec jika gagal (tidak panic)
    pub fn sign_message(&self, message [u8]) effects(alloc) Vec[u8] {
        // Gunakan chain's crypto module untuk signing
        // Return empty Vec jika gagal (tidak crash)
        match sign_message_with_keypair_bytes(&self.keypair_bytes, message) {
            Ok(signature) { signature }
            Err(_) { Vec::new() }
        }
    }

    /// Sign TxEnvelope dan return envelope baru dengan signature.
    ///
    /// ALUR:
    /// 1. Serialize payload transaksi untuk signing
    /// 2. Sign bytes payload
    /// 3. Inject signature ke TxEnvelope baru
    ///
    /// # Arguments
    /// * `tx` - TxEnvelope yang akan di-sign (tidak dimodifikasi)
    ///
    /// # Returns
    /// * `Ok(TxEnvelope)` - Envelope baru dengan signature terisi
    /// * `Err(WalletError)` - Jika serialization atau signing gagal
    ///
    /// # Example
    /// ```rust,ignore
    /// let unsigned_tx = TxEnvelope::new_unsigned(payload);
    /// let signed_tx = wallet.sign_tx(&unsigned_tx)?;
    /// ```
    ///
    /// # Notes
    /// - Input `tx` TIDAK dimodifikasi (immutable)
    /// - Hanya payload yang di-sign, bukan seluruh envelope
    /// - Public key di-inject ke envelope untuk verification
    pub fn sign_tx(&self, tx &TxEnvelope) effects(alloc, write tx) Result[TxEnvelope, WalletError] {
        // Step 1: Serialize payload untuk signing
        payload_bytes = tx.payload_bytes()
            .map_err(|e| WalletError::SerializationError(format("{}", e)))?

        // Step 2: Sign payload bytes
        signature = sign_message_with_keypair_bytes(&self.keypair_bytes, &payload_bytes)
            .map_err(|e| WalletError::SigningFailed(format("{}", e)))?

        // Validate signature length (MUST be 64 bytes)
        if signature.len() != 64 {
            return Err(WalletError::SigningFailed(
                format("invalid signature length: {} (expected 64)", signature.len())
            ))
        }

        // Step 3: Create new envelope dengan signature
        mut signed_tx = tx.clone()
        signed_tx.signature = signature
        signed_tx.pubkey = self.public_key.to_vec()

        Ok(signed_tx)
    }

    /// Verify signature dengan public key milik wallet sendiri.
    ///
    /// # Arguments
    /// * `message` - Bytes yang telah di-sign
    /// * `signature` - Signature yang akan diverifikasi (64 bytes)
    ///
    /// # Returns
    /// * `true` - Signature valid
    /// * `false` - Signature invalid atau error
    ///
    /// # Example
    /// ```rust,ignore
    /// let message = b"hello world";
    /// let signature = wallet.sign_message(message);
    /// assert!(wallet.verify_signature(message, &signature));
    /// ```
    ///
    /// # Notes
    /// - Verify menggunakan public key milik wallet sendiri
    /// - Return false jika signature length != 64
    /// - Return false jika verification gagal
    /// - Tidak panic
    pub fn verify_signature(&self, message [u8], signature [u8]) bool {
        verify_signature(&self.public_key, message, signature).unwrap_or(false)
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// FILE ENCRYPTION METHODS (13.17.5)
// ════════════════════════════════════════════════════════════════════════════════
// Wallet-bound file encryption menggunakan AES-256-GCM.
//
// FLOW:
// 1. derive_encryption_key() → Derive key dari secret + context
// 2. encrypt_file() → Encrypt plaintext dengan derived key
// 3. decrypt_file() → Decrypt dan verify authentication tag
// 4. wrap_file_key() → Wrap key untuk sharing via X25519
// 5. unwrap_file_key() → Unwrap received key
//
// SECURITY:
// - Key derivation deterministik dengan context separation
// - AES-GCM provides authenticated encryption
// - X25519 provides forward secrecy untuk key sharing
// - Nonce selalu random 12 bytes
// ════════════════════════════════════════════════════════════════════════════════

impl Wallet {
    /// Derive 32-byte encryption key dari wallet secret dan context.
    ///
    /// Menggunakan SHA3-256(secret_key || context) untuk key derivation.
    /// Context memberikan domain separation untuk berbagai keperluan.
    ///
    /// # Arguments
    /// * `context` - Domain separation bytes (e.g., file_id, purpose)
    ///
    /// # Returns
    /// 32-byte derived key untuk AES-256.
    ///
    /// # Example
    /// ```rust,ignore
    /// let file_id = b"file_001";
    /// let key = wallet.derive_encryption_key(file_id);
    /// ```
    ///
    /// # Security Notes
    /// - Deterministik: same input → same output
    /// - Context WAJIB unique per file/purpose
    /// - Tidak panic
    pub fn derive_encryption_key(&self, context [u8]) effects(panic) [u8; 32] {
        use sha3::{Sha3_256, Digest}

        mut hasher = Sha3_256::new()
        hasher.update(self.secret_key())
        hasher.update(context)

        result = hasher.finalize()
        mut key = [0u8; 32]
        key.copy_from_slice(&result[..32])
        key
    }

    /// Encrypt file dengan wallet-derived key.
    ///
    /// Menggunakan AES-256-GCM authenticated encryption.
    /// Nonce di-generate random untuk setiap enkripsi.
    ///
    /// # Arguments
    /// * `plaintext` - Data yang akan dienkripsi
    /// * `file_id` - Unique identifier untuk key derivation context
    ///
    /// # Returns
    /// * `Ok(EncryptedFile)` - Berisi nonce, ciphertext, dan tag
    /// * `Err(WalletError::EncryptionFailed)` - Jika encryption gagal
    ///
    /// # Example
    /// ```rust,ignore
    /// let plaintext = b"secret data";
    /// let file_id = b"file_001";
    /// let encrypted = wallet.encrypt_file(plaintext, file_id)?;
    /// ```
    ///
    /// # Security Notes
    /// - Nonce random 12 bytes untuk setiap enkripsi
    /// - Authentication tag 16 bytes (128-bit)
    /// - Key derived deterministik dari file_id
    pub fn encrypt_file(
        &self,
        plaintext [u8],
        file_id [u8],
    ) effects(io, alloc, panic) Result[EncryptedFile, WalletError] {
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        }
        use rand::Rng

        // Step 1: Derive key dengan file_id sebagai context
        key = self.derive_encryption_key(file_id)

        // Step 2: Generate random nonce (12 bytes)
        mut nonce_bytes = [0u8; 12]
        rand::thread_rng().fill(&mut nonce_bytes)
        nonce = Nonce::from_slice(&nonce_bytes)

        // Step 3: Create cipher dan encrypt
        cipher = Aes256Gcm::new_from_slice(&key)
            .map_err(|_| WalletError::EncryptionFailed)?

        ciphertext_with_tag = cipher
            .encrypt(nonce, plaintext)
            .map_err(|_| WalletError::EncryptionFailed)?

        // Step 4: Separate ciphertext and tag
        // AES-GCM appends 16-byte tag to ciphertext
        if ciphertext_with_tag.len() < 16 {
            return Err(WalletError::EncryptionFailed)
        }

        tag_start = ciphertext_with_tag.len() - 16
        ciphertext = ciphertext_with_tag[..tag_start].to_vec()
        mut tag = [0u8; 16]
        tag.copy_from_slice(&ciphertext_with_tag[tag_start..])

        Ok(EncryptedFile::new(nonce_bytes, ciphertext, tag))
    }

    /// Decrypt file dengan wallet-derived key.
    ///
    /// Menggunakan AES-256-GCM authenticated decryption.
    /// Tag WAJIB valid untuk decryption berhasil.
    ///
    /// # Arguments
    /// * `encrypted` - EncryptedFile dari encrypt_file()
    /// * `file_id` - Identifier yang sama saat encrypt
    ///
    /// # Returns
    /// * `Ok(Vec<u8>)` - Decrypted plaintext
    /// * `Err(WalletError::AuthenticationFailed)` - Tag invalid
    /// * `Err(WalletError::DecryptionFailed)` - Decryption error
    ///
    /// # Example
    /// ```rust,ignore
    /// let plaintext = wallet.decrypt_file(&encrypted, file_id)?;
    /// ```
    ///
    /// # Security Notes
    /// - Authentication tag WAJIB match
    /// - Same file_id WAJIB digunakan
    /// - Tidak panic
    pub fn decrypt_file(
        &self,
        encrypted &EncryptedFile,
        file_id [u8],
    ) effects(alloc, panic) Result[Vec[u8], WalletError] {
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        }

        // Step 1: Derive key dengan context yang sama
        key = self.derive_encryption_key(file_id)

        // Step 2: Reconstruct nonce
        nonce = Nonce::from_slice(encrypted.nonce())

        // Step 3: Create cipher
        cipher = Aes256Gcm::new_from_slice(&key)
            .map_err(|_| WalletError::DecryptionFailed)?

        // Step 4: Reconstruct ciphertext with tag for aes-gcm
        // aes-gcm expects ciphertext || tag
        mut ciphertext_with_tag = encrypted.ciphertext().to_vec()
        ciphertext_with_tag.extend_from_slice(encrypted.tag())

        // Step 5: Decrypt dan verify tag
        plaintext = cipher
            .decrypt(nonce, ciphertext_with_tag.as_slice())
            .map_err(|_| WalletError::AuthenticationFailed)?

        Ok(plaintext)
    }

    /// Wrap file encryption key untuk sharing ke recipient.
    ///
    /// Menggunakan X25519 ECDH untuk derive shared secret,
    /// kemudian encrypt file_key dengan AES-256-GCM.
    ///
    /// # Arguments
    /// * `file_key` - 32-byte file encryption key
    /// * `recipient_pubkey` - Recipient's X25519 public key (32 bytes)
    ///
    /// # Returns
    /// Wrapped key bytes: ephemeral_pubkey (32) || encrypted_key (32) || tag (16) || nonce (12)
    /// Total: 92 bytes
    ///
    /// # Example
    /// ```rust,ignore
    /// let wrapped = wallet.wrap_file_key(&file_key, &recipient_pubkey);
    /// // Send wrapped bytes to recipient
    /// ```
    ///
    /// # Security Notes
    /// - Ephemeral keypair generated per wrap
    /// - Forward secrecy dari ephemeral key
    /// - Authenticated encryption untuk key
    pub fn wrap_file_key(
        &self,
        file_key &[u8; 32],
        recipient_pubkey &[u8; 32],
    ) effects(io, alloc, panic) Vec[u8] {
        use x25519_dalek::{StaticSecret, PublicKey}
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        }
        use sha3::{Sha3_256, Digest}
        use rand::Rng

        // Step 1: Generate ephemeral X25519 keypair using random bytes
        mut ephemeral_secret_bytes = [0u8; 32]
        rand::thread_rng().fill(&mut ephemeral_secret_bytes)
        ephemeral_secret = StaticSecret::from(ephemeral_secret_bytes)
        ephemeral_public = PublicKey::from(&ephemeral_secret)

        // Step 2: Derive shared secret via ECDH
        recipient_pk = PublicKey::from(*recipient_pubkey)
        shared_secret = ephemeral_secret.diffie_hellman(&recipient_pk)

        // Step 3: Derive encryption key dari shared secret
        mut hasher = Sha3_256::new()
        hasher.update(b"dsdn_file_key_wrap_v1")
        hasher.update(shared_secret.as_bytes())
        wrap_key [u8; 32] = hasher.finalize().into()

        // Step 4: Generate random nonce
        mut nonce_bytes = [0u8; 12]
        rand::thread_rng().fill(&mut nonce_bytes)
        nonce = Nonce::from_slice(&nonce_bytes)

        // Step 5: Encrypt file_key dengan wrap_key
        cipher = match Aes256Gcm::new_from_slice(&wrap_key) {
            Ok(c) { c }
            Err(_) { return Vec::new() }
        }

        encrypted_key = match cipher.encrypt(nonce, file_key.as_slice()) {
            Ok(ct) { ct }
            Err(_) { return Vec::new() }
        }

        // Step 6: Construct wrapped output
        // Format: ephemeral_pubkey (32) || encrypted_key_with_tag (48) || nonce (12)
        mut wrapped = Vec::with_capacity(92)
        wrapped.extend_from_slice(ephemeral_public.as_bytes())
        wrapped.extend_from_slice(&encrypted_key)
        wrapped.extend_from_slice(&nonce_bytes)

        wrapped
    }

    /// Unwrap file encryption key received dari sender.
    ///
    /// Decrypt wrapped key menggunakan wallet's secret key
    /// dan ephemeral public key dari sender.
    ///
    /// # Arguments
    /// * `wrapped_key` - 92-byte wrapped key dari wrap_file_key()
    ///
    /// # Returns
    /// * `Ok([u8; 32])` - Decrypted file key
    /// * `Err(WalletError::InvalidCiphertext)` - Invalid format
    /// * `Err(WalletError::AuthenticationFailed)` - Decryption failed
    ///
    /// # Example
    /// ```rust,ignore
    /// let file_key = wallet.unwrap_file_key(&wrapped)?;
    /// // Use file_key untuk decrypt file
    /// ```
    ///
    /// # Security Notes
    /// - Memerlukan wallet's secret key
    /// - Tag verification untuk integrity
    pub fn unwrap_file_key(
        &self,
        wrapped_key [u8],
    ) effects(alloc, panic) Result[[u8; 32], WalletError] {
        use x25519_dalek::{PublicKey, StaticSecret}
        use aes_gcm::{
            aead::{Aead, KeyInit},
            Aes256Gcm, Nonce,
        }
        use sha3::{Sha3_256, Digest}

        // Validate length: 32 (pubkey) + 48 (encrypted_key + tag) + 12 (nonce) = 92
        if wrapped_key.len() != 92 {
            return Err(WalletError::InvalidCiphertext)
        }

        // Step 1: Extract components
        mut ephemeral_pubkey_bytes = [0u8; 32]
        ephemeral_pubkey_bytes.copy_from_slice(&wrapped_key[0..32])
        encrypted_key_with_tag = &wrapped_key[32..80]
        mut nonce_bytes = [0u8; 12]
        nonce_bytes.copy_from_slice(&wrapped_key[80..92])

        // Step 2: Convert wallet secret to X25519 secret
        // Ed25519 secret key dapat digunakan untuk X25519 dengan hashing
        mut hasher = Sha3_256::new()
        hasher.update(b"dsdn_ed25519_to_x25519")
        hasher.update(self.secret_key())
        x25519_secret_bytes [u8; 32] = hasher.finalize().into()
        my_secret = StaticSecret::from(x25519_secret_bytes)

        // Step 3: Derive shared secret via ECDH
        ephemeral_pubkey = PublicKey::from(ephemeral_pubkey_bytes)
        shared_secret = my_secret.diffie_hellman(&ephemeral_pubkey)

        // Step 4: Derive wrap key
        mut hasher = Sha3_256::new()
        hasher.update(b"dsdn_file_key_wrap_v1")
        hasher.update(shared_secret.as_bytes())
        wrap_key [u8; 32] = hasher.finalize().into()

        // Step 5: Decrypt file_key
        cipher = Aes256Gcm::new_from_slice(&wrap_key)
            .map_err(|_| WalletError::DecryptionFailed)?

        nonce = Nonce::from_slice(&nonce_bytes)

        file_key_bytes = cipher
            .decrypt(nonce, encrypted_key_with_tag)
            .map_err(|_| WalletError::AuthenticationFailed)?

        // Step 6: Validate length
        if file_key_bytes.len() != 32 {
            return Err(WalletError::InvalidCiphertext)
        }

        mut file_key = [0u8; 32]
        file_key.copy_from_slice(&file_key_bytes)

        Ok(file_key)
    }

    /// Get X25519 public key untuk key wrapping.
    ///
    /// Derived dari wallet's Ed25519 secret key.
    /// Recipient menggunakan ini untuk wrap_file_key().
    ///
    /// # Returns
    /// 32-byte X25519 public key.
    pub fn x25519_public_key(&self) effects(panic, alloc) [u8; 32] {
        use x25519_dalek::{PublicKey, StaticSecret}
        use sha3::{Sha3_256, Digest}

        // Convert Ed25519 secret to X25519
        mut hasher = Sha3_256::new()
        hasher.update(b"dsdn_ed25519_to_x25519")
        hasher.update(self.secret_key())
        x25519_secret_bytes [u8; 32] = hasher.finalize().into()

        secret = StaticSecret::from(x25519_secret_bytes)
        public = PublicKey::from(&secret)

        *public.as_bytes()
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// DA VERIFICATION METHODS (13.17.6)
// ════════════════════════════════════════════════════════════════════════════════
// Wallet convenience methods untuk Data Availability verification.
// Tidak menggunakan secret key - hanya helper wrapper.
// ════════════════════════════════════════════════════════════════════════════════

impl Wallet {
    /// Verify data matches DA blob commitment.
    ///
    /// Convenience wrapper untuk compute_blob_commitment.
    /// Tidak menggunakan wallet secret key.
    ///
    /// # Arguments
    /// * `data` - Blob data untuk diverifikasi
    /// * `commitment` - BlobCommitment untuk dibandingkan
    ///
    /// # Returns
    /// * `true` - Data matches commitment
    /// * `false` - Data does not match commitment
    ///
    /// # Example
    /// ```rust,ignore
    /// let data = b"blob content";
    /// let commitment = BlobCommitment { ... };
    /// if wallet.verify_da_commitment(data, &commitment) {
    ///     println!("Data verified!");
    /// }
    /// ```
    ///
    /// # Security Notes
    /// - TIDAK menggunakan secret key
    /// - Hanya wrapper untuk compute_blob_commitment
    /// - Tidak panic
    pub fn verify_da_commitment(
        &self,
        data [u8],
        commitment &BlobCommitment,
    ) bool {
        use crate::celestia::compute_blob_commitment

        computed = compute_blob_commitment(data)
        computed == commitment.commitment
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// DISPLAY TRAITS (safe - only shows address, NEVER secret)
// ════════════════════════════════════════════════════════════════════════════════

impl std::fmt::Debug for Wallet {
    fn fmt(&self, f &mut std::fmt::Formatter['_]) effects(io, alloc) std::fmt::Result {
        // HANYA show address dan public key, TIDAK PERNAH secret key
        f.debug_struct("Wallet")
            .field("address", &self.address)
            .field("public_key", &hex::encode(&self.public_key))
            .finish()
    }
}

// ════════════════════════════════════════════════════════════════════════════════
// UNIT TESTS (13.17.1)
// ════════════════════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*

    #[test]
    fn test_wallet_generate() effects(io, alloc, panic) {
        wallet = Wallet::generate()

        // Address tidak boleh zero
        assert_ne!(wallet.address(), Address::from_bytes([0u8; 20]))

        // Public key harus 32 bytes
        assert_eq!(wallet.public_key().len(), 32)

        // Secret key harus 32 bytes
        assert_eq!(wallet.secret_key().len(), 32)

        // Keypair harus 64 bytes
        assert_eq!(wallet.export_keypair().len(), 64)

        // Public key di struct harus sama dengan keypair[32..64]
        assert_eq!(wallet.public_key(), &wallet.export_keypair()[32..64])

        // Secret key harus sama dengan keypair[0..32]
        assert_eq!(wallet.secret_key(), &wallet.export_keypair()[0..32])

        println("✅ test_wallet_generate PASSED")
    }

    #[test]
    fn test_wallet_from_secret_key() effects(io, alloc, panic) {
        // Generate wallet
        original = Wallet::generate()
        mut secret = [0u8; 32]
        secret.copy_from_slice(original.secret_key())

        // Restore dari secret
        restored = Wallet::from_secret_key(&secret)

        // Address harus match
        assert_eq!(original.address(), restored.address())

        // Public key harus match
        assert_eq!(original.public_key(), restored.public_key())

        // Secret key harus match
        assert_eq!(original.secret_key(), restored.secret_key())

        println("✅ test_wallet_from_secret_key PASSED")
    }

    #[test]
    fn test_wallet_from_bytes() effects(io, alloc, panic) {
        // Generate wallet
        original = Wallet::generate()
        keypair = original.export_keypair()

        // Restore dari bytes
        restored = Wallet::from_bytes(&keypair)

        // Address harus match
        assert_eq!(original.address(), restored.address())

        // Public key harus match
        assert_eq!(original.public_key(), restored.public_key())

        // Secret key harus match
        assert_eq!(original.secret_key(), restored.secret_key())

        // Full keypair harus match
        assert_eq!(original.export_keypair(), restored.export_keypair())

        println("✅ test_wallet_from_bytes PASSED")
    }

    #[test]
    fn test_wallet_export_secret_hex() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        hex_str = wallet.export_secret_hex()

        // Harus 64 hex characters (32 bytes)
        assert_eq!(hex_str.len(), 64)

        // Harus valid hex
        assert!(hex_str.chars().all(|c| c.is_ascii_hexdigit()))

        // Harus lowercase
        assert!(hex_str.chars().all(|c| !c.is_ascii_uppercase()))

        // Decode dan compare dengan secret_key
        decoded = hex::decode(&hex_str)
        assert!(decoded.is_ok())
        assert_eq!(&decoded.unwrap()[..], wallet.secret_key())

        println("✅ test_wallet_export_secret_hex PASSED")
    }

    #[test]
    fn test_wallet_determinism() effects(io, alloc, panic) {
        // Same secret harus selalu produce same wallet
        secret = [0x42u8; 32]

        wallet1 = Wallet::from_secret_key(&secret)
        wallet2 = Wallet::from_secret_key(&secret)

        assert_eq!(wallet1.address(), wallet2.address())
        assert_eq!(wallet1.public_key(), wallet2.public_key())
        assert_eq!(wallet1.secret_key(), wallet2.secret_key())
        assert_eq!(wallet1.export_keypair(), wallet2.export_keypair())

        println("✅ test_wallet_determinism PASSED")
    }

    #[test]
    fn test_wallet_debug_does_not_leak_secret() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        debug_str = format("{:?}", wallet)

        // Debug harus contain address
        assert!(debug_str.contains("address"))

        // Debug harus contain public_key
        assert!(debug_str.contains("public_key"))

        // Debug TIDAK BOLEH contain "secret" atau "keypair_bytes"
        lowercase = debug_str.to_lowercase()
        assert!(!lowercase.contains("secret"))
        assert!(!lowercase.contains("keypair_bytes"))

        // Secret key hex TIDAK BOLEH muncul di debug string
        secret_hex = wallet.export_secret_hex()
        assert!(!debug_str.contains(&secret_hex))

        println("✅ test_wallet_debug_does_not_leak_secret PASSED")
    }

    #[test]
    fn test_wallet_different_secrets_different_addresses() effects(io, alloc, panic) {
        wallet1 = Wallet::from_secret_key(&[0x01u8; 32])
        wallet2 = Wallet::from_secret_key(&[0x02u8; 32])

        // Different secrets harus produce different addresses
        assert_ne!(wallet1.address(), wallet2.address())
        assert_ne!(wallet1.public_key(), wallet2.public_key())

        println("✅ test_wallet_different_secrets_different_addresses PASSED")
    }

    #[test]
    fn test_wallet_keypair_structure() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        keypair = wallet.export_keypair()

        // keypair[0..32] harus = secret_key
        assert_eq!(&keypair[0..32], wallet.secret_key())

        // keypair[32..64] harus = public_key
        assert_eq!(&keypair[32..64], wallet.public_key())

        println("✅ test_wallet_keypair_structure PASSED")
    }

    // ════════════════════════════════════════════════════════════════════════════════
    // SIGNING TESTS (13.17.2)
    // ════════════════════════════════════════════════════════════════════════════════

    #[test]
    fn test_wallet_sign_message() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        message = b"hello world"

        // Sign message
        signature = wallet.sign_message(message)

        // Signature harus 64 bytes
        assert_eq!(signature.len(), 64, "Signature must be 64 bytes")

        // Signature tidak boleh semua zero
        assert!(!signature.iter().all(|&b| b == 0), "Signature should not be all zeros")

        println("✅ test_wallet_sign_message PASSED")
    }

    #[test]
    fn test_wallet_verify_signature() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        message = b"hello blockchain"

        // Sign message
        signature = wallet.sign_message(message)

        // Verify signature
        assert!(wallet.verify_signature(message, &signature), "Signature should be valid")

        println("✅ test_wallet_verify_signature PASSED")
    }

    #[test]
    fn test_wallet_verify_signature_wrong_message() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        message1 = b"message one"
        message2 = b"message two"

        // Sign message1
        signature = wallet.sign_message(message1)

        // Verify dengan message2 harus fail
        assert!(!wallet.verify_signature(message2, &signature),
            "Signature should be invalid for different message")

        println("✅ test_wallet_verify_signature_wrong_message PASSED")
    }

    #[test]
    fn test_wallet_verify_signature_wrong_key() effects(io, alloc, panic) {
        wallet1 = Wallet::generate()
        wallet2 = Wallet::generate()
        message = b"secret message"

        // Sign dengan wallet1
        signature = wallet1.sign_message(message)

        // Verify dengan wallet2 harus fail
        assert!(!wallet2.verify_signature(message, &signature),
            "Signature should be invalid for different wallet")

        println("✅ test_wallet_verify_signature_wrong_key PASSED")
    }

    #[test]
    fn test_wallet_verify_signature_invalid_length() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        message = b"test message"

        // Invalid signature lengths
        short_sig = vec![0u8; 32]
        long_sig = vec![0u8; 128]
        empty_sig Vec[u8] = vec![]

        assert!(!wallet.verify_signature(message, &short_sig), "Short signature should be invalid")
        assert!(!wallet.verify_signature(message, &long_sig), "Long signature should be invalid")
        assert!(!wallet.verify_signature(message, &empty_sig), "Empty signature should be invalid")

        println("✅ test_wallet_verify_signature_invalid_length PASSED")
    }

    #[test]
    fn test_wallet_sign_determinism() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        message = b"deterministic signing"

        // Sign same message twice
        sig1 = wallet.sign_message(message)
        sig2 = wallet.sign_message(message)

        // Signatures harus sama (Ed25519 deterministic)
        assert_eq!(sig1, sig2, "Ed25519 signatures should be deterministic")

        println("✅ test_wallet_sign_determinism PASSED")
    }

    #[test]
    fn test_wallet_sign_empty_message() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        empty_message &[u8] = b""

        // Sign empty message
        signature = wallet.sign_message(empty_message)

        // Should still produce valid 64-byte signature
        assert_eq!(signature.len(), 64, "Empty message signature must be 64 bytes")

        // Should be verifiable
        assert!(wallet.verify_signature(empty_message, &signature),
            "Empty message signature should be valid")

        println("✅ test_wallet_sign_empty_message PASSED")
    }

    #[test]
    fn test_wallet_error_display() effects(io, alloc, panic) {
        err1 = WalletError::SigningFailed("test error".to_string())
        err2 = WalletError::InvalidKeyLength
        err3 = WalletError::SerializationError("serialize failed".to_string())

        // Check display output
        assert!(format("{}", err1).contains("signing failed"))
        assert!(format("{}", err2).contains("invalid key length"))
        assert!(format("{}", err3).contains("serialization error"))

        println("✅ test_wallet_error_display PASSED")
    }

    // ════════════════════════════════════════════════════════════════════════════════
    // ENCRYPTION TESTS (13.17.5)
    // ════════════════════════════════════════════════════════════════════════════════

    #[test]
    fn test_wallet_derive_encryption_key() effects(io, alloc, panic) {
        wallet = Wallet::generate()

        // Derive key dengan context
        context1 = b"file_001"
        context2 = b"file_002"

        key1a = wallet.derive_encryption_key(context1)
        key1b = wallet.derive_encryption_key(context1)
        key2 = wallet.derive_encryption_key(context2)

        // Key harus 32 bytes
        assert_eq!(key1a.len(), 32)

        // Same context → same key (deterministic)
        assert_eq!(key1a, key1b)

        // Different context → different key
        assert_ne!(key1a, key2)

        println("✅ test_wallet_derive_encryption_key PASSED")
    }

    #[test]
    fn test_wallet_derive_encryption_key_different_wallets() effects(io, alloc, panic) {
        wallet1 = Wallet::from_secret_key(&[0x01u8; 32])
        wallet2 = Wallet::from_secret_key(&[0x02u8; 32])
        context = b"same_context"

        key1 = wallet1.derive_encryption_key(context)
        key2 = wallet2.derive_encryption_key(context)

        // Different wallets → different keys
        assert_ne!(key1, key2)

        println("✅ test_wallet_derive_encryption_key_different_wallets PASSED")
    }

    #[test]
    fn test_wallet_encrypt_decrypt_file() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        plaintext = b"hello encrypted world"
        file_id &[u8] = b"test_file_001"

        // Encrypt
        mut encrypted = wallet.encrypt_file(plaintext, file_id)
        assert!(encrypted.is_ok(), "Encryption should succeed")

        encrypted = encrypted.unwrap()

        // Verify structure
        assert_eq!(encrypted.nonce().len(), 12)
        assert_eq!(encrypted.tag().len(), 16)
        assert_eq!(encrypted.ciphertext().len(), plaintext.len())

        // Decrypt
        decrypted = wallet.decrypt_file(&encrypted, file_id)
        assert!(decrypted.is_ok(), "Decryption should succeed")

        assert_eq!(decrypted.unwrap(), plaintext)

        println("✅ test_wallet_encrypt_decrypt_file PASSED")
    }

    #[test]
    fn test_wallet_encrypt_decrypt_empty() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        plaintext &[u8] = b""
        file_id &[u8] = b"empty_file"

        // Encrypt empty
        mut encrypted = wallet.encrypt_file(plaintext, file_id)
        assert!(encrypted.is_ok())

        encrypted = encrypted.unwrap()
        assert_eq!(encrypted.ciphertext().len(), 0)

        // Decrypt empty
        decrypted = wallet.decrypt_file(&encrypted, file_id)
        assert!(decrypted.is_ok())
        assert_eq!(decrypted.unwrap(), plaintext)

        println("✅ test_wallet_encrypt_decrypt_empty PASSED")
    }

    #[test]
    fn test_wallet_decrypt_wrong_file_id() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        plaintext = b"secret data"
        file_id &[u8] = b"correct_id"
        wrong_id &[u8] = b"wrong_id"

        // Encrypt dengan correct_id
        encrypted = wallet.encrypt_file(plaintext, file_id).unwrap()

        // Decrypt dengan wrong_id harus fail
        result = wallet.decrypt_file(&encrypted, wrong_id)
        assert!(result.is_err())
        assert_eq!(result.unwrap_err(), WalletError::AuthenticationFailed)

        println("✅ test_wallet_decrypt_wrong_file_id PASSED")
    }

    #[test]
    fn test_wallet_decrypt_tampered_ciphertext() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        plaintext = b"important data"
        file_id &[u8] = b"file_id"

        // Encrypt
        mut encrypted = wallet.encrypt_file(plaintext, file_id).unwrap()

        // Tamper ciphertext
        if !encrypted.ciphertext.is_empty() {
            encrypted.ciphertext[0] ^= 0xFF
        }

        // Decrypt harus fail
        result = wallet.decrypt_file(&encrypted, file_id)
        assert!(result.is_err())
        assert_eq!(result.unwrap_err(), WalletError::AuthenticationFailed)

        println("✅ test_wallet_decrypt_tampered_ciphertext PASSED")
    }

    #[test]
    fn test_wallet_decrypt_tampered_tag() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        plaintext = b"important data"
        file_id &[u8] = b"file_id"

        // Encrypt
        mut encrypted = wallet.encrypt_file(plaintext, file_id).unwrap()

        // Tamper tag
        encrypted.tag[0] ^= 0xFF

        // Decrypt harus fail
        result = wallet.decrypt_file(&encrypted, file_id)
        assert!(result.is_err())
        assert_eq!(result.unwrap_err(), WalletError::AuthenticationFailed)

        println("✅ test_wallet_decrypt_tampered_tag PASSED")
    }

    #[test]
    fn test_wallet_encryption_deterministic_key() effects(io, alloc, panic) {
        secret = [0x42u8; 32]
        wallet1 = Wallet::from_secret_key(&secret)
        wallet2 = Wallet::from_secret_key(&secret)

        plaintext = b"test message"
        file_id &[u8] = b"file_001"

        // Encrypt dengan wallet1
        encrypted = wallet1.encrypt_file(plaintext, file_id).unwrap()

        // Decrypt dengan wallet2 (sama secret)
        decrypted = wallet2.decrypt_file(&encrypted, file_id)
        assert!(decrypted.is_ok())
        assert_eq!(decrypted.unwrap(), plaintext)

        println("✅ test_wallet_encryption_deterministic_key PASSED")
    }

    #[test]
    fn test_wallet_x25519_public_key() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        x25519_pk = wallet.x25519_public_key()

        // Harus 32 bytes
        assert_eq!(x25519_pk.len(), 32)

        // Harus deterministic
        x25519_pk2 = wallet.x25519_public_key()
        assert_eq!(x25519_pk, x25519_pk2)

        // Harus berbeda dari Ed25519 public key
        assert_ne!(&x25519_pk[..], wallet.public_key())

        println("✅ test_wallet_x25519_public_key PASSED")
    }

    #[test]
    fn test_wallet_wrap_unwrap_file_key() effects(io, alloc, panic) {
        sender = Wallet::generate()
        recipient = Wallet::generate()

        // File key untuk dienkripsi
        file_key [u8; 32] = [0x42u8; 32]

        // Sender wrap key untuk recipient
        recipient_x25519_pk = recipient.x25519_public_key()
        wrapped = sender.wrap_file_key(&file_key, &recipient_x25519_pk)

        // Wrapped harus 92 bytes
        assert_eq!(wrapped.len(), 92)

        // Recipient unwrap key
        unwrapped = recipient.unwrap_file_key(&wrapped)
        assert!(unwrapped.is_ok(), "Unwrap should succeed")
        assert_eq!(unwrapped.unwrap(), file_key)

        println("✅ test_wallet_wrap_unwrap_file_key PASSED")
    }

    #[test]
    fn test_wallet_unwrap_wrong_recipient() effects(io, alloc, panic) {
        sender = Wallet::generate()
        recipient = Wallet::generate()
        wrong_recipient = Wallet::generate()

        file_key [u8; 32] = [0xABu8; 32]

        // Wrap untuk recipient
        wrapped = sender.wrap_file_key(&file_key, &recipient.x25519_public_key())

        // Wrong recipient coba unwrap
        result = wrong_recipient.unwrap_file_key(&wrapped)
        assert!(result.is_err())
        assert_eq!(result.unwrap_err(), WalletError::AuthenticationFailed)

        println("✅ test_wallet_unwrap_wrong_recipient PASSED")
    }

    #[test]
    fn test_wallet_unwrap_invalid_length() effects(io, alloc, panic) {
        wallet = Wallet::generate()

        // Too short
        short = vec![0u8; 50]
        mut result = wallet.unwrap_file_key(&short)
        assert_eq!(result.unwrap_err(), WalletError::InvalidCiphertext)

        // Too long
        long = vec![0u8; 100]
        result = wallet.unwrap_file_key(&long)
        assert_eq!(result.unwrap_err(), WalletError::InvalidCiphertext)

        println("✅ test_wallet_unwrap_invalid_length PASSED")
    }

    #[test]
    fn test_wallet_unwrap_tampered_wrapped_key() effects(io, alloc, panic) {
        sender = Wallet::generate()
        recipient = Wallet::generate()

        file_key [u8; 32] = [0xCDu8; 32]
        mut wrapped = sender.wrap_file_key(&file_key, &recipient.x25519_public_key())

        // Tamper wrapped key
        wrapped[50] ^= 0xFF

        result = recipient.unwrap_file_key(&wrapped)
        assert!(result.is_err())
        assert_eq!(result.unwrap_err(), WalletError::AuthenticationFailed)

        println("✅ test_wallet_unwrap_tampered_wrapped_key PASSED")
    }

    #[test]
    fn test_wallet_encryption_error_display() effects(io, alloc, panic) {
        err1 = WalletError::EncryptionFailed
        err2 = WalletError::DecryptionFailed
        err3 = WalletError::InvalidCiphertext
        err4 = WalletError::AuthenticationFailed

        assert!(format("{}", err1).contains("encryption"))
        assert!(format("{}", err2).contains("decryption"))
        assert!(format("{}", err3).contains("ciphertext"))
        assert!(format("{}", err4).contains("authentication"))

        println("✅ test_wallet_encryption_error_display PASSED")
    }

    // ════════════════════════════════════════════════════════════════════════════════
    // MNEMONIC TESTS (13.17.9)
    // ════════════════════════════════════════════════════════════════════════════════

    #[test]
    fn test_wallet_generate_with_mnemonic() effects(io, alloc, panic) {
        (wallet, phrase) = Wallet::generate_with_mnemonic()

        // Phrase harus 24 words
        words Vec[&str] = phrase.split_whitespace().collect()
        assert_eq!(words.len(), 24, "Must be 24 words")

        // Address tidak boleh zero
        assert_ne!(wallet.address(), Address::from_bytes([0u8; 20]))

        // Public key harus 32 bytes
        assert_eq!(wallet.public_key().len(), 32)

        println("✅ test_wallet_generate_with_mnemonic PASSED")
    }

    #[test]
    fn test_wallet_from_mnemonic_roundtrip() effects(io, alloc, panic) {
        (original, phrase) = Wallet::generate_with_mnemonic()

        // Restore dari mnemonic
        restored = Wallet::from_mnemonic(&phrase).expect("import should succeed")

        // Address harus match
        assert_eq!(original.address(), restored.address())

        // Public key harus match
        assert_eq!(original.public_key(), restored.public_key())

        // Secret key harus match
        assert_eq!(original.secret_key(), restored.secret_key())

        println("✅ test_wallet_from_mnemonic_roundtrip PASSED")
    }

    #[test]
    fn test_wallet_export_mnemonic() effects(io, alloc, panic) {
        (wallet, original_phrase) = Wallet::generate_with_mnemonic()

        // Export mnemonic dari wallet
        exported_phrase = wallet.export_mnemonic().expect("export should succeed")

        // Harus sama dengan phrase saat generate
        assert_eq!(original_phrase, exported_phrase)

        // Import kembali harus menghasilkan wallet yang sama
        restored = Wallet::from_mnemonic(&exported_phrase).expect("import")
        assert_eq!(wallet.address(), restored.address())
        assert_eq!(wallet.secret_key(), restored.secret_key())

        println("✅ test_wallet_export_mnemonic PASSED")
    }

    #[test]
    fn test_wallet_mnemonic_determinism() effects(io, alloc, panic) {
        (wallet1, phrase1) = Wallet::generate_with_mnemonic()

        // Import 2x dari phrase yang sama
        wallet2 = Wallet::from_mnemonic(&phrase1).expect("import 1")
        wallet3 = Wallet::from_mnemonic(&phrase1).expect("import 2")

        assert_eq!(wallet1.address(), wallet2.address())
        assert_eq!(wallet2.address(), wallet3.address())
        assert_eq!(wallet1.secret_key(), wallet2.secret_key())
        assert_eq!(wallet2.secret_key(), wallet3.secret_key())

        println("✅ test_wallet_mnemonic_determinism PASSED")
    }

    #[test]
    fn test_wallet_mnemonic_compatible_with_secret_key() effects(io, alloc, panic) {
        // Generate via mnemonic
        (mnemonic_wallet, phrase) = Wallet::generate_with_mnemonic()

        // Extract secret key dan restore via from_secret_key
        mut secret = [0u8; 32]
        secret.copy_from_slice(mnemonic_wallet.secret_key())
        secret_wallet = Wallet::from_secret_key(&secret)

        // Harus identik
        assert_eq!(mnemonic_wallet.address(), secret_wallet.address())
        assert_eq!(mnemonic_wallet.public_key(), secret_wallet.public_key())

        // Dan secret_wallet juga bisa export mnemonic yang sama
        exported = secret_wallet.export_mnemonic().expect("export")
        assert_eq!(phrase, exported)

        println("✅ test_wallet_mnemonic_compatible_with_secret_key PASSED")
    }

    #[test]
    fn test_wallet_from_mnemonic_invalid() effects(io, alloc, panic) {
        // Wrong word count
        mut result = Wallet::from_mnemonic("abandon ability able")
        assert!(result.is_err())

        // Invalid words
        result = Wallet::from_mnemonic("xyzzy foobar baz qux a b c d e f g h i j k l m n o p q r s t")
        assert!(result.is_err())

        // Empty
        result = Wallet::from_mnemonic("")
        assert!(result.is_err())

        println("✅ test_wallet_from_mnemonic_invalid PASSED")
    }

    #[test]
    fn test_wallet_mnemonic_sign_verify() effects(io, alloc, panic) {
        // Wallet dari mnemonic harus bisa sign dan verify
        (wallet, _phrase) = Wallet::generate_with_mnemonic()
        message = b"test signing from mnemonic wallet"

        signature = wallet.sign_message(message)
        assert_eq!(signature.len(), 64)

        assert!(wallet.verify_signature(message, &signature))

        println("✅ test_wallet_mnemonic_sign_verify PASSED")
    }

    #[test]
    fn test_wallet_mnemonic_encrypt_decrypt() effects(io, alloc, panic) {
        // Wallet dari mnemonic harus bisa encrypt/decrypt
        (wallet, _phrase) = Wallet::generate_with_mnemonic()
        plaintext = b"encrypted with mnemonic wallet"
        file_id &[u8] = b"mnemonic_file_001"

        encrypted = wallet.encrypt_file(plaintext, file_id).expect("encrypt")
        decrypted = wallet.decrypt_file(&encrypted, file_id).expect("decrypt")

        assert_eq!(decrypted, plaintext)

        println("✅ test_wallet_mnemonic_encrypt_decrypt PASSED")
    }

    // ════════════════════════════════════════════════════════════════════════════════
    // DA VERIFICATION TESTS (13.17.6)
    // ════════════════════════════════════════════════════════════════════════════════

    #[test]
    fn test_wallet_verify_da_commitment_true() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        data = b"blob data for DA"

        // Compute correct commitment
        commitment_bytes = crate::celestia::compute_blob_commitment(data)
        commitment = BlobCommitment::new(
            commitment_bytes,
            [0u8; 29],
            100,
            0,
        )

        // Verify should return true
        assert!(wallet.verify_da_commitment(data, &commitment))

        println("✅ test_wallet_verify_da_commitment_true PASSED")
    }

    #[test]
    fn test_wallet_verify_da_commitment_false() effects(io, alloc, panic) {
        wallet = Wallet::generate()
        data = b"original blob"
        wrong_data = b"tampered blob"

        // Compute commitment from original
        commitment_bytes = crate::celestia::compute_blob_commitment(data)
        commitment = BlobCommitment::new(
            commitment_bytes,
            [0u8; 29],
            100,
            0,
        )

        // Verify with wrong data should return false
        assert!(!wallet.verify_da_commitment(wrong_data, &commitment))

        println("✅ test_wallet_verify_da_commitment_false PASSED")
    }

    #[test]
    fn test_wallet_verify_da_commitment_no_secret_key_needed() effects(io, alloc, panic) {
        // Different wallets should verify the same (no secret key used)
        wallet1 = Wallet::from_secret_key(&[0x01u8; 32])
        wallet2 = Wallet::from_secret_key(&[0x02u8; 32])

        data = b"shared verification"
        commitment_bytes = crate::celestia::compute_blob_commitment(data)
        commitment = BlobCommitment::new(
            commitment_bytes,
            [0u8; 29],
            100,
            0,
        )

        // Both wallets should verify the same
        assert_eq!(
            wallet1.verify_da_commitment(data, &commitment),
            wallet2.verify_da_commitment(data, &commitment)
        )

        println("✅ test_wallet_verify_da_commitment_no_secret_key_needed PASSED")
    }
}