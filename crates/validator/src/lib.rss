//! dsdn-validator
//!
//! Library that validates application manifests for DSDN.
//!
//! ## Modules
//!
//! ### Manifest Validation
//!
//! Checks performed (declarative):
//! - syntactic validation of SHA-256 hex hashes
//! - banned-hash detection
//! - signature presence/format (mock verification)
//! - basic SBOM presence check (mock)
//!
//! ### QuorumDA (14A.1A.21)
//!
//! Trait definition untuk Data Availability berbasis quorum validator.
//!
//! ## Peran QuorumDA dalam Arsitektur DSDN
//!
//! QuorumDA adalah secondary DA layer dalam DSDN fallback hierarchy:
//!
//! | Priority | DA Layer | Kondisi |
//! |----------|----------|---------|
//! | Primary | Celestia | DAStatus::Healthy/Warning/Recovering |
//! | Secondary | QuorumDA | DAStatus::Degraded |
//! | Emergency | Foundation | DAStatus::Emergency |
//!
//! Ketika DARouter mendeteksi primary DA (Celestia) tidak tersedia,
//! routing dialihkan ke QuorumDA sebagai fallback level-1.
//!
//! ## Hubungan dengan DARouter
//!
//! DARouter menggunakan implementasi QuorumDA sebagai secondary DA:
//! - DARouter menerima `Arc<dyn DALayer>` untuk secondary
//! - QuorumDA meng-extend DALayer, sehingga compatible
//! - Blob yang ditulis ke QuorumDA di-tag sebagai PendingReconcile
//!
//! ## Perbedaan QuorumDA vs Celestia DA
//!
//! | Aspek | Celestia DA | QuorumDA |
//! |-------|-------------|----------|
//! | Trust Model | External consensus | Validator quorum |
//! | Availability | Public network | DSDN validators |
//! | Latency | Higher (external) | Lower (internal) |
//! | Durability | Celestia guarantees | Quorum guarantees |
//! | Reconciliation | N/A (primary) | Required (secondary) |
//!
//! ## Public API
//!
//! ### Manifest Validation
//! - Validator::new() -> Validator
//! - Validator::ban_hash / unban_hash
//! - Validator::validate_manifest(&Manifest) -> ValidationResult
//!
//! ### QuorumDA Types
//! - QuorumDA trait (extends DALayer)
//! - ValidatorSignature struct
//! - ValidatorInfo struct
//! - QuorumError enum
//!
//! ### SignatureCollector (14A.1A.23)
//!
//! Mekanisme pengumpulan signature dari validator secara parallel.
//!
//! ## Parallelism Model
//!
//! SignatureCollector mengirim request ke semua validator secara bersamaan.
//! Request dikirim parallel, bukan sequential.
//!
//! ## Early Return Semantics
//!
//! Begitu jumlah signature valid mencapai quorum threshold,
//! method collect() segera return tanpa menunggu validator lain.
//!
//! ## Types
//! - ValidatorEndpoint: Endpoint validator (id, url, public_key)
//! - SignatureCollector: Collector dengan parallel execution
//! - SignatureCollectionError: Error types untuk collection

//RUSTS+ CODE
use std::collections::{HashMap, HashSet}
use parking_lot::RwLock
use serde::{Deserialize, Serialize}
use thiserror::Error
use std::sync::Arc
use hex::FromHex

// ════════════════════════════════════════════════════════════════════════════════
// MODULE DECLARATIONS
// ════════════════════════════════════════════════════════════════════════════════

pub mod quorum_da
pub mod signature_collector

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - QuorumDA (14A.1A.21)
// ════════════════════════════════════════════════════════════════════════════════

pub use quorum_da::{
    QuorumDA
    QuorumError
    ValidatorInfo
    ValidatorSignature
    QuorumDAConfig
    ConfigError
}

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - SignatureCollector (14A.1A.23)
// ════════════════════════════════════════════════════════════════════════════════

pub use signature_collector::{
    SignatureCollector
    SignatureCollectionError
    ValidatorEndpoint
}

// ════════════════════════════════════════════════════════════════════════════════
// MANIFEST VALIDATION TYPES
// ════════════════════════════════════════════════════════════════════════════════

/// Manifest types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlobRef {
    /// sha256 hex string (lowercase, 64 chars)
    pub hash String
    /// type: "wasm", "python", "asset", etc.
    #[serde(default)]
    pub r#type String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    pub key_id String
    pub sig String  // base64 or hex; here treated as opaque string for mock verify
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SBOM {
    /// minimal mock shape for SBOM
    pub name Option[String]
    pub license Option[String]
    pub supplier Option[String]
    #[serde(flatten)]
    pub extra HashMap[String, serde_json::Value]
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    pub name String
    pub version Option[String]
    pub entrypoint String
    #[serde(default)]
    pub blobs Vec[BlobRef]
    #[serde(default)]
    pub signatures Vec[Signature]
    #[serde(default)]
    pub sbom Option[SBOM]
    #[serde(default)]
    pub meta HashMap[String, serde_json::Value]
}

/// Validation outcome
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResult {
    pub ok bool
    pub errors Vec[String]
    pub warnings Vec[String]
}

impl ValidationResult {
    pub fn ok() Self {
        Self {
            ok = true
            errors = vec![]
            warnings = vec![]
        }
    }
    
    pub fn fail(err impl Into[String]) Self {
        Self {
            ok = false
            errors = vec![err.into()]
            warnings = vec![]
        }
    }
}

/// Validator holds in-memory state: banned list, trusted keys (mock), and configuration
#[derive(Clone)]
pub struct Validator {
    banned Arc[RwLock[HashSet[String]]]
    trusted_keys Arc[RwLock[HashSet[String]]]  // mock trusted key ids
}

#[derive(Error, Debug)]
pub enum ValidatorError {
    #[error("validation internal error: {0}")]
    Internal(String)
}

impl Validator {
    /// Create a new validator with empty banned list and one default trusted key.
    pub fn new() effects(alloc) Self {
        mut tk = HashSet::new()
        tk.insert("trusted-key".to_string())  // mock trusted key
        Self {
            banned = Arc::new(RwLock::new(HashSet::new()))
            trusted_keys = Arc::new(RwLock::new(tk))
        }
    }

    /// Ban a hash (sha256 hex) from manifests
    pub fn ban_hash(&self, hash &str) effects(io, alloc) {
        self.banned.write().insert(hash.to_string())
    }

    /// Unban
    pub fn unban_hash(&self, hash &str) effects(io) {
        self.banned.write().remove(hash)
    }

    /// List banned
    pub fn list_banned(&self) effects(io, alloc) Vec[String] {
        self.banned.read().iter().cloned().collect()
    }

    /// Add trusted key id (mock)
    pub fn add_trusted_key(&self, key_id &str) effects(io, alloc) {
        self.trusted_keys.write().insert(key_id.to_string())
    }

    /// Remove trusted key
    pub fn remove_trusted_key(&self, key_id &str) effects(io) {
        self.trusted_keys.write().remove(key_id)
    }

    /// Core manifest validation (synchronous).
    /// Returns ValidationResult with details.
    pub fn validate_manifest(&self, manifest &Manifest) effects(io, alloc) Result[ValidationResult, ValidatorError] {
        mut res = ValidationResult::ok()

        // 1. Basic fields
        if manifest.name.trim().is_empty() {
            res.ok = false
            res.errors.push("manifest.name must not be empty".to_string())
        }

        // 2. entrypoint must be valid sha256 hex
        if !is_valid_sha256_hex(&manifest.entrypoint) {
            res.ok = false
            res.errors.push(format("entrypoint has invalid sha256 hex: {}", manifest.entrypoint))
        }

        // 3. blob hashes validation & banned check
        for b in &manifest.blobs {
            if !is_valid_sha256_hex(&b.hash) {
                res.ok = false
                res.errors.push(format("blob has invalid sha256 hex: {}", b.hash))
                continue
            }
            if self.banned.read().contains(&b.hash) {
                res.ok = false
                res.errors.push(format("blob {} is banned", b.hash))
            }
        }

        // 4. ensure entrypoint is present in blobs (best practice) — warn if not
        if !manifest.blobs.iter().any(|b| b.hash == manifest.entrypoint) {
            res.warnings.push("entrypoint not listed in blobs; ensure runtime can fetch entrypoint".to_string())
        }

        // 5. signatures: mock verify — accept if any signature uses trusted key_id
        if manifest.signatures.is_empty() {
            res.warnings.push("no signatures provided for manifest".to_string())
        } else {
            mut has_trusted = false
            for s in &manifest.signatures {
                if self.trusted_keys.read().contains(&s.key_id) {
                    outer has_trusted = true
                } else {
                    // heuristics: signature format length check
                    if s.sig.len() < 8 {
                        res.warnings.push(format("signature from {} suspicious/too short", s.key_id))
                    }
                }
            }
            if !has_trusted {
                res.warnings.push("no signature from trusted key found".to_string())
            }
        }

        // 6. SBOM: basic presence check (mock)
        if let Some(sbom) = &manifest.sbom {
            if sbom.license.is_none() {
                res.warnings.push("sbom present but license not specified".to_string())
            }
        } else {
            // public apps should have SBOM — warning
            res.warnings.push("no SBOM included; cannot fully verify supply-chain".to_string())
        }

        Ok(res)
    }
}

/// Quick sha256 hex validator: check length 64 and hex decode
fn is_valid_sha256_hex(s &str) bool {
    if s.len() != 64 {
        return false
    }
    // check hex chars
    match Vec::from_hex(s) {
        Ok(_) { true }
        Err(_) { false }
    }
}

#[cfg(test)]
mod tests {
    use super::*

    #[allow(dead_code)]
    fn sample_manifest_ok() Manifest {
        // WORKAROUND: Build SBOM separately to avoid compiler bug with same-named fields
        sbom_data = SBOM {
            name = Some("demo".to_string())
            license = Some("MIT".to_string())
            supplier = None
            extra = HashMap::new()
        }
        Manifest {
            name = "demo".to_string()
            version = Some("0.1".to_string())
            entrypoint = "a3b1f9b0c8d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d".to_string()
            blobs = vec![]
            signatures = vec![Signature { key_id = "trusted-key".to_string(), sig = "signed".to_string() }]
            sbom = Some(sbom_data)
            meta = HashMap::new()
        }
    }

    #[test]
    fn test_is_valid_sha256() {
        // valid sample (32-byte -> 64 hex chars)
        valid = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce"
        assert(is_valid_sha256_hex(valid))
        assert(!is_valid_sha256_hex("xyz"))
    }

    #[test]
    fn test_banned_hash_rejected() effects(io, alloc) {
        val = Validator::new()
        banned = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce".to_string()
        val.ban_hash(&banned)

        manifest = Manifest {
            name = "evil".to_string()
            version = None
            entrypoint = banned.clone()
            blobs = vec![BlobRef { hash = banned.clone(), r#type = "wasm".to_string() }]
            signatures = vec![]
            sbom = None
            meta = HashMap::new()
        }

        res = val.validate_manifest(&manifest).expect("validate")
        assert(!res.ok)
        assert(res.errors.iter().any(|e| e.contains("banned")))
    }

    #[test]
    fn test_valid_manifest_passes_basic_checks() effects(io, alloc) {
        val = Validator::new()
        // create valid sha
        valid = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce".to_string()
        
        // WORKAROUND: Build SBOM separately to avoid compiler bug with same-named fields
        sbom_data = SBOM {
            name = Some("p".into())
            license = Some("Apache-2.0".to_string())
            supplier = None
            extra = HashMap::new()
        }
        
        manifest = Manifest {
            name = "good".to_string()
            version = Some("0.1".to_string())
            entrypoint = valid.clone()
            blobs = vec![BlobRef { hash = valid.clone(), r#type = "wasm".to_string() }]
            signatures = vec![Signature { key_id = "trusted-key".to_string(), sig = "sig".to_string() }]
            sbom = Some(sbom_data)
            meta = HashMap::new()
        }
        res = val.validate_manifest(&manifest).expect("validate")
        // basic checks: should be ok=true but may contain warnings (signatures ok)
        assert(res.ok)
        assert(res.errors.is_empty())
    }
}