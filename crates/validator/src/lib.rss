//! dsdn-validator
//!
//! Library that validates application manifests for DSDN and provides
//! QuorumDA - a validator-based Data Availability layer.
//!
//! # Modules Overview
//!
//! ## Manifest Validation
//!
//! Checks performed (declarative):
//! - Syntactic validation of SHA-256 hex hashes
//! - Banned-hash detection
//! - Signature presence/format (mock verification)
//! - Basic SBOM presence check (mock)
//!
//! ## QuorumDA System (14A.1A.21 - 14A.1A.30)
//!
//! Complete validator-based Data Availability implementation.
//!
//! # QuorumDA Architecture
//!
//! ## Peran dalam Sistem DSDN
//!
//! QuorumDA adalah **secondary DA layer** dalam DSDN fallback hierarchy.
//! QuorumDA BUKAN replacement untuk Celestia - ini adalah fallback mechanism
//! yang aktif hanya ketika primary DA tidak tersedia.
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────┐
//! │                    DARouter                                  │
//! │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
//! │  │  Celestia   │  │  QuorumDA   │  │  Foundation DA      │  │
//! │  │  (Primary)  │  │ (Secondary) │  │  (Emergency)        │  │
//! │  │  Priority 1 │  │  Priority 2 │  │  Priority 3         │  │
//! │  └─────────────┘  └─────────────┘  └─────────────────────┘  │
//! └─────────────────────────────────────────────────────────────┘
//! ```
//!
//! | Priority | DA Layer | Kondisi Aktif |
//! |----------|----------|---------------|
//! | 1 (Primary) | Celestia | DAStatus::Healthy, Warning, Recovering |
//! | 2 (Secondary) | QuorumDA | DAStatus::Degraded |
//! | 3 (Emergency) | Foundation | DAStatus::Emergency |
//!
//! ## Hubungan dengan DALayer Trait
//!
//! QuorumDA meng-extend trait `DALayer` dari `dsdn_common`:
//!
//! ```text
//! trait DALayer {
//!     fn post_blob(&self, data: &[u8]) -> Result<BlobRef, DAError>;
//!     fn get_blob(&self, ref_: &BlobRef) -> Result<Vec<u8>, DAError>;
//!     fn health_check(&self) -> Result<DAHealthStatus, DAError>;
//!     // ...
//! }
//!
//! trait QuorumDA: DALayer {
//!     fn active_validators(&self) -> Vec<ValidatorInfo>;
//!     fn quorum_threshold(&self) -> usize;
//!     fn collect_signatures(&self, data_hash: &[u8; 32]) -> Result<...>;
//!     fn verify_quorum_signatures(&self, ...) -> Result<QuorumVerification, ...>;
//!     fn submit_with_signatures(&self, ...) -> Result<BlobRef, ...>;
//! }
//! ```
//!
//! Ini memungkinkan DARouter menggunakan `Arc<dyn DALayer>` untuk
//! QuorumDA tanpa perlu tahu implementasi spesifik.
//!
//! ## Reconciliation Requirement
//!
//! Blob yang ditulis ke QuorumDA di-tag dengan `pending_reconcile = true`.
//! Background process akan melakukan reconciliation ke Celestia
//! ketika primary DA kembali healthy.
//!
//! # Signature Collection Flow
//!
//! ## Alur Data Lengkap
//!
//! ```text
//! ┌──────────┐    ┌─────────────┐    ┌──────────────────┐
//! │   Data   │───>│  SHA-256    │───>│  SignatureCollector
//! │  (blob)  │    │   Hash      │    │  (parallel)      │
//! └──────────┘    └─────────────┘    └────────┬─────────┘
//!                                              │
//!                     ┌────────────────────────┴──────────┐
//!                     │                                   │
//!              ┌──────▼──────┐                    ┌───────▼──────┐
//!              │ Validator 1 │                    │ Validator N  │
//!              │  (sign)     │                    │  (sign)      │
//!              └──────┬──────┘                    └───────┬──────┘
//!                     │                                   │
//!                     └────────────────┬──────────────────┘
//!                                      │
//!                              ┌───────▼────────┐
//!                              │ Quorum Check   │
//!                              │ (threshold)    │
//!                              └───────┬────────┘
//!                                      │
//!                     ┌────────────────┴────────────────┐
//!                     │                                 │
//!              ┌──────▼──────┐                  ┌───────▼──────┐
//!              │  Success    │                  │   Failure    │
//!              │ (>= 2/3)    │                  │  (< 2/3)     │
//!              └──────┬──────┘                  └───────┬──────┘
//!                     │                                 │
//!              ┌──────▼──────┐                  ┌───────▼──────┐
//!              │ Store Blob  │                  │ Return Error │
//!              │ + Metadata  │                  │              │
//!              └─────────────┘                  └──────────────┘
//! ```
//!
//! ## Early Return Semantics
//!
//! SignatureCollector mengimplementasikan early return:
//! - Request dikirim ke SEMUA validator secara parallel
//! - Begitu `threshold` signatures valid terkumpul, return immediately
//! - Pending requests di-cancel (tidak ditunggu)
//! - Ini mengoptimalkan latency: tidak perlu tunggu validator lambat
//!
//! ## Failure Modes
//!
//! | Mode | Penyebab | Handling |
//! |------|----------|----------|
//! | Timeout | Validator tidak merespon dalam `signature_timeout_ms` | Skip validator, lanjut ke yang lain |
//! | Invalid Signature | Signature tidak match dengan public key | Reject signature, tidak dihitung |
//! | Insufficient Quorum | Jumlah signature valid < threshold | Return QuorumError::InsufficientQuorum |
//! | Network Error | Connection refused, DNS failure | Log error, skip validator |
//!
//! # Trust Model
//!
//! ## Asumsi Kepercayaan
//!
//! QuorumDA mengasumsikan trust model berikut:
//!
//! 1. **Validator Honesty**: Mayoritas validator (>= 2/3) diasumsikan jujur
//! 2. **Key Security**: Private keys validator aman dan tidak compromised
//! 3. **Network Reliability**: Jaringan antar validator reasonable (tidak 100% partitioned)
//! 4. **Clock Synchronization**: Timestamps validator dalam reasonable bound
//!
//! ## Quorum Threshold
//!
//! Default threshold: **67% (2/3 + 1)** dari total validator
//!
//! ```text
//! threshold = ceil(total_validators * quorum_fraction)
//! threshold = max(threshold, min_validators)
//!
//! Contoh: 10 validators, quorum_fraction = 0.67
//! threshold = ceil(10 * 0.67) = ceil(6.7) = 7
//! ```
//!
//! ## Konsekuensi Validator Jahat / Offline
//!
//! | Skenario | Impact | Mitigasi |
//! |----------|--------|----------|
//! | < 1/3 validators jahat | Tidak bisa forge quorum | Threshold 2/3 mencegah |
//! | >= 1/3 validators offline | Quorum tidak tercapai | Fallback ke Foundation DA |
//! | >= 2/3 validators collude | Data bisa dimanipulasi | **TIDAK ADA MITIGASI** |
//! | Single validator offline | Tidak ada impact | Early return dari validator lain |
//!
//! ## Batasan Keamanan (EKSPLISIT)
//!
//! **PERINGATAN**: QuorumDA memiliki batasan keamanan berikut:
//!
//! 1. **Bukan Byzantine Fault Tolerant penuh**: Jika >= 2/3 validators
//!    berkolusi, mereka dapat memanipulasi data. Tidak ada mekanisme
//!    slashing atau accountability.
//!
//! 2. **Tidak ada data availability sampling**: Tidak seperti Celestia,
//!    QuorumDA tidak memiliki mekanisme DAS. Client harus trust quorum.
//!
//! 3. **Centralization risk**: Validator set dikelola oleh DSDN governance.
//!    Perubahan validator set adalah operasi terpusat.
//!
//! 4. **Temporary storage**: QuorumDA adalah fallback sementara.
//!    Data HARUS di-reconcile ke Celestia untuk durability jangka panjang.
//!
//! 5. **No erasure coding**: Data disimpan full, bukan erasure coded.
//!    Storage requirement = full data size * replication factor.
//!
//! # Usage Examples (Descriptive)
//!
//! ## Membuat ValidatorQuorumDA
//!
//! ```text
//! // 1. Siapkan konfigurasi
//! config = QuorumDAConfig::default()
//!     atau
//! config = QuorumDAConfig::from_env()  // dari environment variables
//!
//! // 2. Siapkan validator endpoints
//! endpoints = [
//!     ValidatorEndpoint { id: "v1", url: "http://...", public_key: [...] },
//!     ValidatorEndpoint { id: "v2", url: "http://...", public_key: [...] },
//! ]
//!
//! // 3. Buat SignatureCollector
//! collector = SignatureCollector::new(endpoints, config, http_client)
//!
//! // 4. Buat ValidatorQuorumDA
//! quorum_da = ValidatorQuorumDA::new(config, collector, validators, runtime)
//! ```
//!
//! ## Posting Blob
//!
//! ```text
//! // QuorumDA implements DALayer, so:
//! data = [byte array]
//! blob_ref = quorum_da.post_blob(&data).await
//!
//! // Internally:
//! // 1. Compute SHA-256 hash of data
//! // 2. Collect signatures from validators (parallel)
//! // 3. Verify quorum threshold reached
//! // 4. Store blob with metadata
//! // 5. Return BlobRef
//! ```
//!
//! ## Retrieving Blob
//!
//! ```text
//! blob_ref = ...  // dari post_blob atau external source
//! data = quorum_da.get_blob(&blob_ref).await
//!
//! // Internally:
//! // 1. Lookup in local storage
//! // 2. Re-verify quorum signatures
//! // 3. Verify data hash integrity
//! // 4. Return data
//! ```
//!
//! ## Monitoring dengan Metrics
//!
//! ```text
//! metrics = quorum_da.metrics()
//!
//! // Get individual counters
//! blobs_stored = metrics.get_blobs_stored()
//! quorum_failures = metrics.get_quorum_failures()
//!
//! // Export to Prometheus format
//! prometheus_text = metrics.to_prometheus()
//! // Output: "dsdn_quorum_blobs_stored_total 42\n..."
//! ```
//!
//! # Public API Summary
//!
//! ## Manifest Validation
//! - `Validator::new()` - Create validator instance
//! - `Validator::ban_hash()` / `unban_hash()` - Manage banned hashes
//! - `Validator::validate_manifest()` - Validate manifest
//!
//! ## QuorumDA Core
//! - `QuorumDA` - Trait extending DALayer
//! - `ValidatorQuorumDA` - Production implementation
//! - `QuorumDAConfig` - Configuration struct
//! - `ValidatorInfo` - Validator metadata
//! - `ValidatorSignature` - Signed data from validator
//! - `QuorumVerification` - Verification result
//!
//! ## Signature Collection
//! - `SignatureCollector` - Parallel signature collector
//! - `ValidatorEndpoint` - Validator endpoint info
//! - `SignatureCollectionError` - Collection errors
//!
//! ## Metrics
//! - `QuorumMetrics` - Metrics tracking with Prometheus export

//RUSTS+ CODE
use std::collections::{HashMap, HashSet}
use parking_lot::RwLock
use serde::{Deserialize, Serialize}
use thiserror::Error
use std::sync::Arc
use hex::FromHex

// ════════════════════════════════════════════════════════════════════════════════
// MODULE DECLARATIONS
// ════════════════════════════════════════════════════════════════════════════════

pub mod quorum_da
pub mod signature_collector
pub mod metrics_tracking

// Coordinator Selection (14A.2B.2)
#[path = "coordinator_selection.rs"]
pub mod coordinator_selection

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - QuorumDA (14A.1A.21 - 14A.1A.28)
// ════════════════════════════════════════════════════════════════════════════════

/// QuorumDA trait dan types untuk validator-based Data Availability.
pub use quorum_da::{
    // Trait
    QuorumDA

    // Implementation
    ValidatorQuorumDA

    // Configuration
    QuorumDAConfig
    ConfigError

    // Validator types
    ValidatorInfo
    ValidatorSignature

    // Verification
    QuorumVerification

    // Errors
    QuorumError
}

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - SignatureCollector (14A.1A.23)
// ════════════════════════════════════════════════════════════════════════════════

/// SignatureCollector untuk parallel signature collection dari validators.
pub use signature_collector::{
    SignatureCollector
    SignatureCollectionError
    ValidatorEndpoint
}

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - QuorumMetrics (14A.1A.29)
// ════════════════════════════════════════════════════════════════════════════════

/// Metrics tracking untuk QuorumDA dengan Prometheus export.
pub use metrics_tracking::QuorumMetrics

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - Coordinator Selection (14A.2B.2)
// ════════════════════════════════════════════════════════════════════════════════

/// Coordinator selection types untuk multi-coordinator consensus.
pub use coordinator_selection::{
    ValidatorCandidate
    SelectionWeight
    CoordinatorMember
    CoordinatorCommittee
    CommitteeInvariantError
    SelectionConfig
}

// ════════════════════════════════════════════════════════════════════════════════
// MANIFEST VALIDATION TYPES
// ════════════════════════════════════════════════════════════════════════════════

/// Manifest types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlobRef {
    /// sha256 hex string (lowercase, 64 chars)
    pub hash String
    /// type: "wasm", "python", "asset", etc.
    #[serde(default)]
    pub r#type String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    pub key_id String
    pub sig String  // base64 or hex; here treated as opaque string for mock verify
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SBOM {
    /// minimal mock shape for SBOM
    pub name Option[String]
    pub license Option[String]
    pub supplier Option[String]
    #[serde(flatten)]
    pub extra HashMap[String, serde_json::Value]
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    pub name String
    pub version Option[String]
    pub entrypoint String
    #[serde(default)]
    pub blobs Vec[BlobRef]
    #[serde(default)]
    pub signatures Vec[Signature]
    #[serde(default)]
    pub sbom Option[SBOM]
    #[serde(default)]
    pub meta HashMap[String, serde_json::Value]
}

/// Validation outcome
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResult {
    pub ok bool
    pub errors Vec[String]
    pub warnings Vec[String]
}

impl ValidationResult {
    pub fn ok() Self {
        Self {
            ok = true
            errors = vec![]
            warnings = vec![]
        }
    }
    
    pub fn fail(err impl Into[String]) Self {
        Self {
            ok = false
            errors = vec![err.into()]
            warnings = vec![]
        }
    }
}

/// Validator holds in-memory state: banned list, trusted keys (mock), and configuration
#[derive(Clone)]
pub struct Validator {
    banned Arc[RwLock[HashSet[String]]]
    trusted_keys Arc[RwLock[HashSet[String]]]  // mock trusted key ids
}

#[derive(Error, Debug)]
pub enum ValidatorError {
    #[error("validation internal error: {0}")]
    Internal(String)
}

impl Validator {
    /// Create a new validator with empty banned list and one default trusted key.
    pub fn new() effects(alloc) Self {
        mut tk = HashSet::new()
        tk.insert("trusted-key".to_string())  // mock trusted key
        Self {
            banned = Arc::new(RwLock::new(HashSet::new()))
            trusted_keys = Arc::new(RwLock::new(tk))
        }
    }

    /// Ban a hash (sha256 hex) from manifests
    pub fn ban_hash(&self, hash &str) effects(io, alloc) {
        self.banned.write().insert(hash.to_string())
    }

    /// Unban
    pub fn unban_hash(&self, hash &str) effects(io) {
        self.banned.write().remove(hash)
    }

    /// List banned
    pub fn list_banned(&self) effects(io, alloc) Vec[String] {
        self.banned.read().iter().cloned().collect()
    }

    /// Add trusted key id (mock)
    pub fn add_trusted_key(&self, key_id &str) effects(io, alloc) {
        self.trusted_keys.write().insert(key_id.to_string())
    }

    /// Remove trusted key
    pub fn remove_trusted_key(&self, key_id &str) effects(io) {
        self.trusted_keys.write().remove(key_id)
    }

    /// Core manifest validation (synchronous).
    /// Returns ValidationResult with details.
    pub fn validate_manifest(&self, manifest &Manifest) effects(io, alloc) Result[ValidationResult, ValidatorError] {
        mut res = ValidationResult::ok()

        // 1. Basic fields
        if manifest.name.trim().is_empty() {
            res.ok = false
            res.errors.push("manifest.name must not be empty".to_string())
        }

        // 2. entrypoint must be valid sha256 hex
        if !is_valid_sha256_hex(&manifest.entrypoint) {
            res.ok = false
            res.errors.push(format("entrypoint has invalid sha256 hex: {}", manifest.entrypoint))
        }

        // 3. blob hashes validation & banned check
        for b in &manifest.blobs {
            if !is_valid_sha256_hex(&b.hash) {
                res.ok = false
                res.errors.push(format("blob has invalid sha256 hex: {}", b.hash))
                continue
            }
            if self.banned.read().contains(&b.hash) {
                res.ok = false
                res.errors.push(format("blob {} is banned", b.hash))
            }
        }

        // 4. ensure entrypoint is present in blobs (best practice) — warn if not
        if !manifest.blobs.iter().any(|b| b.hash == manifest.entrypoint) {
            res.warnings.push("entrypoint not listed in blobs; ensure runtime can fetch entrypoint".to_string())
        }

        // 5. signatures: mock verify — accept if any signature uses trusted key_id
        if manifest.signatures.is_empty() {
            res.warnings.push("no signatures provided for manifest".to_string())
        } else {
            mut has_trusted = false
            for s in &manifest.signatures {
                if self.trusted_keys.read().contains(&s.key_id) {
                    outer has_trusted = true
                } else {
                    // heuristics: signature format length check
                    if s.sig.len() < 8 {
                        res.warnings.push(format("signature from {} suspicious/too short", s.key_id))
                    }
                }
            }
            if !has_trusted {
                res.warnings.push("no signature from trusted key found".to_string())
            }
        }

        // 6. SBOM: basic presence check (mock)
        if let Some(sbom) = &manifest.sbom {
            if sbom.license.is_none() {
                res.warnings.push("sbom present but license not specified".to_string())
            }
        } else {
            // public apps should have SBOM — warning
            res.warnings.push("no SBOM included; cannot fully verify supply-chain".to_string())
        }

        Ok(res)
    }
}

/// Quick sha256 hex validator: check length 64 and hex decode
fn is_valid_sha256_hex(s &str) bool {
    if s.len() != 64 {
        return false
    }
    // check hex chars
    match Vec::from_hex(s) {
        Ok(_) { true }
        Err(_) { false }
    }
}

#[cfg(test)]
mod tests {
    use super::*

    #[allow(dead_code)]
    fn sample_manifest_ok() Manifest {
        // WORKAROUND: Build SBOM separately to avoid compiler bug with same-named fields
        sbom_data = SBOM {
            name = Some("demo".to_string())
            license = Some("MIT".to_string())
            supplier = None
            extra = HashMap::new()
        }
        Manifest {
            name = "demo".to_string()
            version = Some("0.1".to_string())
            entrypoint = "a3b1f9b0c8d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d".to_string()
            blobs = vec![]
            signatures = vec![Signature { key_id = "trusted-key".to_string(), sig = "signed".to_string() }]
            sbom = Some(sbom_data)
            meta = HashMap::new()
        }
    }

    #[test]
    fn test_is_valid_sha256() {
        // valid sample (32-byte -> 64 hex chars)
        valid = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce"
        assert(is_valid_sha256_hex(valid))
        assert(!is_valid_sha256_hex("xyz"))
    }

    #[test]
    fn test_banned_hash_rejected() effects(io, alloc) {
        val = Validator::new()
        banned = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce".to_string()
        val.ban_hash(&banned)

        manifest = Manifest {
            name = "evil".to_string()
            version = None
            entrypoint = banned.clone()
            blobs = vec![BlobRef { hash = banned.clone(), r#type = "wasm".to_string() }]
            signatures = vec![]
            sbom = None
            meta = HashMap::new()
        }

        res = val.validate_manifest(&manifest).expect("validate")
        assert(!res.ok)
        assert(res.errors.iter().any(|e| e.contains("banned")))
    }

    #[test]
    fn test_valid_manifest_passes_basic_checks() effects(io, alloc) {
        val = Validator::new()
        // create valid sha
        valid = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce".to_string()
        
        // WORKAROUND: Build SBOM separately to avoid compiler bug with same-named fields
        sbom_data = SBOM {
            name = Some("p".into())
            license = Some("Apache-2.0".to_string())
            supplier = None
            extra = HashMap::new()
        }
        
        manifest = Manifest {
            name = "good".to_string()
            version = Some("0.1".to_string())
            entrypoint = valid.clone()
            blobs = vec![BlobRef { hash = valid.clone(), r#type = "wasm".to_string() }]
            signatures = vec![Signature { key_id = "trusted-key".to_string(), sig = "sig".to_string() }]
            sbom = Some(sbom_data)
            meta = HashMap::new()
        }
        res = val.validate_manifest(&manifest).expect("validate")
        // basic checks: should be ok=true but may contain warnings (signatures ok)
        assert(res.ok)
        assert(res.errors.is_empty())
    }
}