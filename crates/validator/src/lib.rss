//! dsdn-validator
//!
//! Library that validates application manifests for DSDN and provides
//! QuorumDA - a validator-based Data Availability layer.
//!
//! # Modules Overview
//!
//! ## Manifest Validation
//!
//! Checks performed (declarative):
//! - Syntactic validation of SHA-256 hex hashes
//! - Banned-hash detection
//! - Signature presence/format (mock verification)
//! - Basic SBOM presence check (mock)
//!
//! ## QuorumDA System (14A.1A.21 - 14A.1A.30)
//!
//! Complete validator-based Data Availability implementation.
//!
//! ## Gating Verifiers (14B)
//!
//! Stateless verifiers for service node admission gating.
//!
//! | Verifier | Module | Description |
//! |----------|--------|-------------|
//! | `StakeVerifier` | `gating::stake_verifier` | Validates stake meets minimum per NodeClass (14B.21) |
//!
//! All verifiers are stateless, deterministic, and produce `CheckResult`
//! or `GatingError` without accessing chain state.
//!
//! # QuorumDA Architecture
//!
//! ## Peran dalam Sistem DSDN
//!
//! QuorumDA adalah **secondary DA layer** dalam DSDN fallback hierarchy.
//! QuorumDA BUKAN replacement untuk Celestia - ini adalah fallback mechanism
//! yang aktif hanya ketika primary DA tidak tersedia.
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────┐
//! │                    DARouter                                  │
//! │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
//! │  │  Celestia   │  │  QuorumDA   │  │  Foundation DA      │  │
//! │  │  (Primary)  │  │ (Secondary) │  │  (Emergency)        │  │
//! │  │  Priority 1 │  │  Priority 2 │  │  Priority 3         │  │
//! │  └─────────────┘  └─────────────┘  └─────────────────────┘  │
//! └─────────────────────────────────────────────────────────────┘
//! ```
//!
//! | Priority | DA Layer | Kondisi Aktif |
//! |----------|----------|---------------|
//! | 1 (Primary) | Celestia | DAStatus::Healthy, Warning, Recovering |
//! | 2 (Secondary) | QuorumDA | DAStatus::Degraded |
//! | 3 (Emergency) | Foundation | DAStatus::Emergency |
//!
//! ## Hubungan dengan DALayer Trait
//!
//! QuorumDA meng-extend trait `DALayer` dari `dsdn_common`:
//!
//! ```text
//! trait DALayer {
//!     fn post_blob(&self, data: &[u8]) -> Result<BlobRef, DAError>;
//!     fn get_blob(&self, ref_: &BlobRef) -> Result<Vec<u8>, DAError>;
//!     fn health_check(&self) -> Result<DAHealthStatus, DAError>;
//!     // ...
//! }
//!
//! trait QuorumDA: DALayer {
//!     fn active_validators(&self) -> Vec<ValidatorInfo>;
//!     fn quorum_threshold(&self) -> usize;
//!     fn collect_signatures(&self, data_hash: &[u8; 32]) -> Result<...>;
//!     fn verify_quorum_signatures(&self, ...) -> Result<QuorumVerification, ...>;
//!     fn submit_with_signatures(&self, ...) -> Result<BlobRef, ...>;
//! }
//! ```
//!
//! Ini memungkinkan DARouter menggunakan `Arc<dyn DALayer>` untuk
//! QuorumDA tanpa perlu tahu implementasi spesifik.
//!
//! ## Reconciliation Requirement
//!
//! Blob yang ditulis ke QuorumDA di-tag dengan `pending_reconcile = true`.
//! Background process akan melakukan reconciliation ke Celestia
//! ketika primary DA kembali healthy.
//!
//! # Signature Collection Flow
//!
//! ## Alur Data Lengkap
//!
//! ```text
//! ┌──────────┐    ┌─────────────┐    ┌──────────────────┐
//! │   Data   │───>│  SHA-256    │───>│  SignatureCollector
//! │  (blob)  │    │   Hash      │    │  (parallel)      │
//! └──────────┘    └─────────────┘    └────────┬─────────┘
//!                                              │
//!                     ┌────────────────────────┴──────────┐
//!                     │                                   │
//!              ┌──────▼──────┐                    ┌───────▼──────┐
//!              │ Validator 1 │                    │ Validator N  │
//!              │  (sign)     │                    │  (sign)      │
//!              └──────┬──────┘                    └───────┬──────┘
//!                     │                                   │
//!                     └────────────────┬──────────────────┘
//!                                      │
//!                              ┌───────▼────────┐
//!                              │ Quorum Check   │
//!                              │ (threshold)    │
//!                              └───────┬────────┘
//!                                      │
//!                     ┌────────────────┴────────────────┐
//!                     │                                 │
//!              ┌──────▼──────┐                  ┌───────▼──────┐
//!              │  Success    │                  │   Failure    │
//!              │ (>= 2/3)    │                  │  (< 2/3)     │
//!              └──────┬──────┘                  └───────┬──────┘
//!                     │                                 │
//!              ┌──────▼──────┐                  ┌───────▼──────┐
//!              │ Store Blob  │                  │ Return Error │
//!              │ + Metadata  │                  │              │
//!              └─────────────┘                  └──────────────┘
//! ```
//!
//! ## Early Return Semantics
//!
//! SignatureCollector mengimplementasikan early return:
//! - Request dikirim ke SEMUA validator secara parallel
//! - Begitu `threshold` signatures valid terkumpul, return immediately
//! - Pending requests di-cancel (tidak ditunggu)
//! - Ini mengoptimalkan latency: tidak perlu tunggu validator lambat
//!
//! ## Failure Modes
//!
//! | Mode | Penyebab | Handling |
//! |------|----------|----------|
//! | Timeout | Validator tidak merespon dalam `signature_timeout_ms` | Skip validator, lanjut ke yang lain |
//! | Invalid Signature | Signature tidak match dengan public key | Reject signature, tidak dihitung |
//! | Insufficient Quorum | Jumlah signature valid < threshold | Return QuorumError::InsufficientQuorum |
//! | Network Error | Connection refused, DNS failure | Log error, skip validator |
//!
//! # Trust Model
//!
//! ## Asumsi Kepercayaan
//!
//! QuorumDA mengasumsikan trust model berikut:
//!
//! 1. **Validator Honesty**: Mayoritas validator (>= 2/3) diasumsikan jujur
//! 2. **Key Security**: Private keys validator aman dan tidak compromised
//! 3. **Network Reliability**: Jaringan antar validator reasonable (tidak 100% partitioned)
//! 4. **Clock Synchronization**: Timestamps validator dalam reasonable bound
//!
//! ## Quorum Threshold
//!
//! Default threshold: **67% (2/3 + 1)** dari total validator
//!
//! ```text
//! threshold = ceil(total_validators * quorum_fraction)
//! threshold = max(threshold, min_validators)
//!
//! Contoh: 10 validators, quorum_fraction = 0.67
//! threshold = ceil(10 * 0.67) = ceil(6.7) = 7
//! ```
//!
//! ## Konsekuensi Validator Jahat / Offline
//!
//! | Skenario | Impact | Mitigasi |
//! |----------|--------|----------|
//! | < 1/3 validators jahat | Tidak bisa forge quorum | Threshold 2/3 mencegah |
//! | >= 1/3 validators offline | Quorum tidak tercapai | Fallback ke Foundation DA |
//! | >= 2/3 validators collude | Data bisa dimanipulasi | **TIDAK ADA MITIGASI** |
//! | Single validator offline | Tidak ada impact | Early return dari validator lain |
//!
//! ## Batasan Keamanan (EKSPLISIT)
//!
//! **PERINGATAN**: QuorumDA memiliki batasan keamanan berikut:
//!
//! 1. **Bukan Byzantine Fault Tolerant penuh**: Jika >= 2/3 validators
//!    berkolusi, mereka dapat memanipulasi data. Tidak ada mekanisme
//!    slashing atau accountability.
//!
//! 2. **Tidak ada data availability sampling**: Tidak seperti Celestia,
//!    QuorumDA tidak memiliki mekanisme DAS. Client harus trust quorum.
//!
//! 3. **Centralization risk**: Validator set dikelola oleh DSDN governance.
//!    Perubahan validator set adalah operasi terpusat.
//!
//! 4. **Temporary storage**: QuorumDA adalah fallback sementara.
//!    Data HARUS di-reconcile ke Celestia untuk durability jangka panjang.
//!
//! 5. **No erasure coding**: Data disimpan full, bukan erasure coded.
//!    Storage requirement = full data size * replication factor.
//!
//! # Usage Examples (Descriptive)
//!
//! ## Membuat ValidatorQuorumDA
//!
//! ```text
//! // 1. Siapkan konfigurasi
//! config = QuorumDAConfig::default()
//!     atau
//! config = QuorumDAConfig::from_env()  // dari environment variables
//!
//! // 2. Siapkan validator endpoints
//! endpoints = [
//!     ValidatorEndpoint { id: "v1", url: "http://...", public_key: [...] },
//!     ValidatorEndpoint { id: "v2", url: "http://...", public_key: [...] },
//! ]
//!
//! // 3. Buat SignatureCollector
//! collector = SignatureCollector::new(endpoints, config, http_client)
//!
//! // 4. Buat ValidatorQuorumDA
//! quorum_da = ValidatorQuorumDA::new(config, collector, validators, runtime)
//! ```
//!
//! ## Posting Blob
//!
//! ```text
//! // QuorumDA implements DALayer, so:
//! data = [byte array]
//! blob_ref = quorum_da.post_blob(&data).await
//!
//! // Internally:
//! // 1. Compute SHA-256 hash of data
//! // 2. Collect signatures from validators (parallel)
//! // 3. Verify quorum threshold reached
//! // 4. Store blob with metadata
//! // 5. Return BlobRef
//! ```
//!
//! ## Retrieving Blob
//!
//! ```text
//! blob_ref = ...  // dari post_blob atau external source
//! data = quorum_da.get_blob(&blob_ref).await
//!
//! // Internally:
//! // 1. Lookup in local storage
//! // 2. Re-verify quorum signatures
//! // 3. Verify data hash integrity
//! // 4. Return data
//! ```
//!
//! ## Monitoring dengan Metrics
//!
//! ```text
//! metrics = quorum_da.metrics()
//!
//! // Get individual counters
//! blobs_stored = metrics.get_blobs_stored()
//! quorum_failures = metrics.get_quorum_failures()
//!
//! // Export to Prometheus format
//! prometheus_text = metrics.to_prometheus()
//! // Output: "dsdn_quorum_blobs_stored_total 42\n..."
//! ```
//!
//! # Public API Summary
//!
//! ## Manifest Validation
//! - `Validator::new()` - Create validator instance
//! - `Validator::ban_hash()` / `unban_hash()` - Manage banned hashes
//! - `Validator::validate_manifest()` - Validate manifest
//!
//! ## QuorumDA Core
//! - `QuorumDA` - Trait extending DALayer
//! - `ValidatorQuorumDA` - Production implementation
//! - `QuorumDAConfig` - Configuration struct
//! - `ValidatorInfo` - Validator metadata
//! - `ValidatorSignature` - Signed data from validator
//! - `QuorumVerification` - Verification result
//!
//! ## Signature Collection
//! - `SignatureCollector` - Parallel signature collector
//! - `ValidatorEndpoint` - Validator endpoint info
//! - `SignatureCollectionError` - Collection errors
//!
//! ## Metrics
//! - `QuorumMetrics` - Metrics tracking with Prometheus export
//!
//! ## Coordinator Selection (14A.2B.2)
//!
//! Sistem seleksi committee deterministik untuk multi-coordinator consensus.
//!
//! ### Architecture Diagram
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────────────────┐
//! │                     Coordinator Selection System                         │
//! │                                                                          │
//! │  ┌──────────────┐     ┌───────────────────┐     ┌──────────────────┐    │
//! │  │  Validators  │────>│ CoordinatorSelector│────>│ CoordinatorCommittee│ │
//! │  │  (candidates)│     │   (selection)      │     │  (members + threshold)│
//! │  └──────────────┘     └───────────────────┘     └──────────────────┘    │
//! │         │                      │                         │               │
//! │         │              ┌───────┴───────┐                 │               │
//! │         │              │               │                 │               │
//! │         ▼              ▼               ▼                 ▼               │
//! │  ┌──────────┐   ┌───────────┐   ┌───────────┐   ┌──────────────┐        │
//! │  │ValidatorID│   │ EpochSeed │   │ Selection │   │ Verification │        │
//! │  │ + Stake  │   │(DA + prev)│   │   Config  │   │  (re-select) │        │
//! │  │ + Zone   │   └───────────┘   └───────────┘   └──────────────┘        │
//! │  └──────────┘                                                            │
//! └─────────────────────────────────────────────────────────────────────────┘
//! ```
//!
//! ### Selection Flow Diagram
//!
//! ```text
//! ┌───────────────────────────────────────────────────────────────────────┐
//! │                       Selection Algorithm Flow                         │
//! │                                                                        │
//! │  Step 1: Validator Filtering                                           │
//! │  ┌────────────────┐                                                    │
//! │  │ All Validators │                                                    │
//! │  └───────┬────────┘                                                    │
//! │          │ filter: stake >= min_stake                                  │
//! │          ▼                                                             │
//! │  ┌────────────────┐                                                    │
//! │  │    Eligible    │                                                    │
//! │  │   Validators   │                                                    │
//! │  └───────┬────────┘                                                    │
//! │          │                                                             │
//! │  Step 2: Deterministic Shuffle (ChaCha20 PRNG seeded by epoch_seed)    │
//! │          │                                                             │
//! │          ▼                                                             │
//! │  ┌────────────────┐                                                    │
//! │  │    Shuffled    │                                                    │
//! │  │   Candidates   │                                                    │
//! │  └───────┬────────┘                                                    │
//! │          │                                                             │
//! │  Step 3: Zone Diversity Selection (max 1/3 per zone, best effort)      │
//! │          │                                                             │
//! │          ▼                                                             │
//! │  ┌────────────────┐                                                    │
//! │  │   Selected     │                                                    │
//! │  │   Members      │                                                    │
//! │  └───────┬────────┘                                                    │
//! │          │                                                             │
//! │  Step 4: Final Sort (by stake descending)                              │
//! │          │                                                             │
//! │          ▼                                                             │
//! │  ┌────────────────┐                                                    │
//! │  │ Coordinator    │ threshold = config.threshold                       │
//! │  │ Committee      │ epoch = input epoch                                │
//! │  │                │ group_pubkey = placeholder (DKG later)             │
//! │  └────────────────┘                                                    │
//! └───────────────────────────────────────────────────────────────────────┘
//! ```
//!
//! ### Trust Model
//!
//! | Aspek | Status | Keterangan |
//! |-------|--------|------------|
//! | Epoch Seed | Deterministic | Derived from DA blob hash + prev committee hash |
//! | Selection Algorithm | Deterministic | Same inputs = same output (ChaCha20 PRNG) |
//! | Committee Verification | Verifiable | Any node can re-run selection to verify |
//! | Validator Set | Trusted Input | Must come from trusted source (governance) |
//! | Merkle Proof | Verifiable | SHA3-512 truncated, standard Merkle verification |
//!
//! **Determinism Guarantee**: Given identical inputs (validators, epoch, seed, config),
//! `select_committee` ALWAYS produces identical output on any node, any architecture.
//!
//! **Verifiability**: Any node receiving a claimed committee can verify it by:
//! 1. Re-running `select_committee` with same inputs
//! 2. Comparing byte-wise equality of all fields
//! 3. Verifying epoch seed via Merkle proof against DA layer
//!
//! ### Public API Summary
//!
//! | Type/Function | Role |
//! |---------------|------|
//! | `ValidatorCandidate` | Validator eligible for selection (id, pubkey, stake, zone) |
//! | `SelectionWeight` | Weight data for cumulative stake calculation |
//! | `CoordinatorMember` | Selected member in committee |
//! | `CoordinatorCommittee` | Committee with members, threshold, epoch, group_pubkey |
//! | `SelectionConfig` | Configuration: committee_size, threshold, min_stake |
//! | `CoordinatorSelector` | Stateless selection engine |
//! | `SelectionError` | Errors during selection (insufficient validators, etc.) |
//! | `VerificationError` | Errors during committee verification |
//! | `derive_epoch_seed` | Derive epoch seed from DA blob and prev committee |
//! | `verify_epoch_seed` | Verify epoch seed against Merkle proof |
//! | `verify_committee_selection` | Verify committee is valid selection result |
//! | `verify_member_eligibility` | Verify member exists in validator set |
//!
//! ### Usage Example
//!
//! ```ignore
//! use dsdn_validator::{
//!     SelectionConfig, CoordinatorSelector, ValidatorCandidate,
//!     derive_epoch_seed,
//! };
//!
//! // 1. Create configuration
//! let config = SelectionConfig {
//!     committee_size: 5,
//!     threshold: 3,
//!     min_stake: 1000,
//! };
//!
//! // 2. Create selector (returns Result, no unwrap in production)
//! let selector = match CoordinatorSelector::new(config) {
//!     Ok(s) => s,
//!     Err(e) => {
//!         eprintln!("Invalid config: {}", e);
//!         return;
//!     }
//! };
//!
//! // 3. Prepare validators (from governance/registry)
//! let validators: Vec<ValidatorCandidate> = vec![
//!     // ... populate from trusted source
//! ];
//!
//! // 4. Derive epoch seed
//! let epoch = 100u64;
//! let da_blob_hash = [0u8; 32];      // from DA layer
//! let prev_committee_hash = [0u8; 32]; // from previous committee
//! let seed = derive_epoch_seed(epoch, &da_blob_hash, &prev_committee_hash);
//!
//! // 5. Select committee (returns Result)
//! match selector.select_committee(&validators, epoch, &seed) {
//!     Ok(committee) => {
//!         println!("Selected {} members", committee.members.len());
//!         println!("Threshold: {}", committee.threshold);
//!     }
//!     Err(e) => {
//!         eprintln!("Selection failed: {}", e);
//!     }
//! }
//! ```

//RUSTS+ CODE
use std::collections::{HashMap, HashSet}
use parking_lot::RwLock
use serde::{Deserialize, Serialize}
use thiserror::Error
use std::sync::Arc
use hex::FromHex

// ════════════════════════════════════════════════════════════════════════════════
// MODULE DECLARATIONS
// ════════════════════════════════════════════════════════════════════════════════

pub mod quorum_da
pub mod signature_collector
pub mod metrics_tracking

// Coordinator Selection (14A.2B.2)
pub mod coordinator_selection

// Gating Verifiers (14B)
pub mod gating

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - QuorumDA (14A.1A.21 - 14A.1A.28)
// ════════════════════════════════════════════════════════════════════════════════

/// QuorumDA trait dan types untuk validator-based Data Availability.
pub use quorum_da::{
    // Trait
    QuorumDA

    // Implementation
    ValidatorQuorumDA

    // Configuration
    QuorumDAConfig
    ConfigError

    // Validator types
    ValidatorInfo
    ValidatorSignature

    // Verification
    QuorumVerification

    // Errors
    QuorumError
}

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - SignatureCollector (14A.1A.23)
// ════════════════════════════════════════════════════════════════════════════════

/// SignatureCollector untuk parallel signature collection dari validators.
pub use signature_collector::{
    SignatureCollector
    SignatureCollectionError
    ValidatorEndpoint
}

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - QuorumMetrics (14A.1A.29)
// ════════════════════════════════════════════════════════════════════════════════

/// Metrics tracking untuk QuorumDA dengan Prometheus export.
pub use metrics_tracking::QuorumMetrics

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - Coordinator Selection (14A.2B.2)
// ════════════════════════════════════════════════════════════════════════════════

/// Coordinator selection types untuk multi-coordinator consensus.
pub use coordinator_selection::{
    // Base types (14A.2B.2.1)
    ValidatorCandidate
    SelectionWeight
    CoordinatorMember
    CoordinatorCommittee
    CommitteeInvariantError
    SelectionConfig

    // Selector (14A.2B.2.2)
    CoordinatorSelector
    SelectorConfigError

    // Selection errors (14A.2B.2.7 + 14A.2B.2.9)
    SelectionError

    // Seed derivation (14A.2B.2.5)
    derive_epoch_seed

    // Verification (14A.2B.2.6 + 14A.2B.2.8)
    DAMerkleProof
    SeedVerificationResult
    verify_epoch_seed
    verify_merkle_proof
    VerificationError
    verify_committee_selection
    verify_member_eligibility
}

// ════════════════════════════════════════════════════════════════════════════════
// PUBLIC EXPORTS - Gating Verifiers (14B)
// ════════════════════════════════════════════════════════════════════════════════

/// StakeVerifier for service node stake validation.
pub use gating::StakeVerifier

// ════════════════════════════════════════════════════════════════════════════════
// MANIFEST VALIDATION TYPES
// ════════════════════════════════════════════════════════════════════════════════

/// Manifest types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlobRef {
    /// sha256 hex string (lowercase, 64 chars)
    pub hash String
    /// type: "wasm", "python", "asset", etc.
    #[serde(default)]
    pub r#type String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    pub key_id String
    pub sig String  // base64 or hex; here treated as opaque string for mock verify
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SBOM {
    /// minimal mock shape for SBOM
    pub name Option[String]
    pub license Option[String]
    pub supplier Option[String]
    #[serde(flatten)]
    pub extra HashMap[String, serde_json::Value]
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    pub name String
    pub version Option[String]
    pub entrypoint String
    #[serde(default)]
    pub blobs Vec[BlobRef]
    #[serde(default)]
    pub signatures Vec[Signature]
    #[serde(default)]
    pub sbom Option[SBOM]
    #[serde(default)]
    pub meta HashMap[String, serde_json::Value]
}

/// Validation outcome
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResult {
    pub ok bool
    pub errors Vec[String]
    pub warnings Vec[String]
}

impl ValidationResult {
    pub fn ok() Self {
        Self {
            ok = true
            errors = vec![]
            warnings = vec![]
        }
    }
    
    pub fn fail(err impl Into[String]) Self {
        Self {
            ok = false
            errors = vec![err.into()]
            warnings = vec![]
        }
    }
}

/// Validator holds in-memory state: banned list, trusted keys (mock), and configuration
#[derive(Clone)]
pub struct Validator {
    banned Arc[RwLock[HashSet[String]]]
    trusted_keys Arc[RwLock[HashSet[String]]]  // mock trusted key ids
}

#[derive(Error, Debug)]
pub enum ValidatorError {
    #[error("validation internal error: {0}")]
    Internal(String)
}

impl Validator {
    /// Create a new validator with empty banned list and one default trusted key.
    pub fn new() effects(alloc) Self {
        mut tk = HashSet::new()
        tk.insert("trusted-key".to_string())  // mock trusted key
        Self {
            banned = Arc::new(RwLock::new(HashSet::new()))
            trusted_keys = Arc::new(RwLock::new(tk))
        }
    }

    /// Ban a hash (sha256 hex) from manifests
    pub fn ban_hash(&self, hash &str) effects(io, alloc) {
        self.banned.write().insert(hash.to_string())
    }

    /// Unban
    pub fn unban_hash(&self, hash &str) effects(io) {
        self.banned.write().remove(hash)
    }

    /// List banned
    pub fn list_banned(&self) effects(io, alloc) Vec[String] {
        self.banned.read().iter().cloned().collect()
    }

    /// Add trusted key id (mock)
    pub fn add_trusted_key(&self, key_id &str) effects(io, alloc) {
        self.trusted_keys.write().insert(key_id.to_string())
    }

    /// Remove trusted key
    pub fn remove_trusted_key(&self, key_id &str) effects(io) {
        self.trusted_keys.write().remove(key_id)
    }

    /// Core manifest validation (synchronous).
    /// Returns ValidationResult with details.
    pub fn validate_manifest(&self, manifest &Manifest) effects(io, alloc) Result[ValidationResult, ValidatorError] {
        mut res = ValidationResult::ok()

        // 1. Basic fields
        if manifest.name.trim().is_empty() {
            res.ok = false
            res.errors.push("manifest.name must not be empty".to_string())
        }

        // 2. entrypoint must be valid sha256 hex
        if !is_valid_sha256_hex(&manifest.entrypoint) {
            res.ok = false
            res.errors.push(format("entrypoint has invalid sha256 hex: {}", manifest.entrypoint))
        }

        // 3. blob hashes validation & banned check
        for b in &manifest.blobs {
            if !is_valid_sha256_hex(&b.hash) {
                res.ok = false
                res.errors.push(format("blob has invalid sha256 hex: {}", b.hash))
                continue
            }
            if self.banned.read().contains(&b.hash) {
                res.ok = false
                res.errors.push(format("blob {} is banned", b.hash))
            }
        }

        // 4. ensure entrypoint is present in blobs (best practice) — warn if not
        if !manifest.blobs.iter().any(|b| b.hash == manifest.entrypoint) {
            res.warnings.push("entrypoint not listed in blobs; ensure runtime can fetch entrypoint".to_string())
        }

        // 5. signatures: mock verify — accept if any signature uses trusted key_id
        if manifest.signatures.is_empty() {
            res.warnings.push("no signatures provided for manifest".to_string())
        } else {
            mut has_trusted = false
            for s in &manifest.signatures {
                if self.trusted_keys.read().contains(&s.key_id) {
                    outer has_trusted = true
                } else {
                    // heuristics: signature format length check
                    if s.sig.len() < 8 {
                        res.warnings.push(format("signature from {} suspicious/too short", s.key_id))
                    }
                }
            }
            if !has_trusted {
                res.warnings.push("no signature from trusted key found".to_string())
            }
        }

        // 6. SBOM: basic presence check (mock)
        if let Some(sbom) = &manifest.sbom {
            if sbom.license.is_none() {
                res.warnings.push("sbom present but license not specified".to_string())
            }
        } else {
            // public apps should have SBOM — warning
            res.warnings.push("no SBOM included; cannot fully verify supply-chain".to_string())
        }

        Ok(res)
    }
}

/// Quick sha256 hex validator: check length 64 and hex decode
fn is_valid_sha256_hex(s &str) bool {
    if s.len() != 64 {
        return false
    }
    // check hex chars
    match Vec::from_hex(s) {
        Ok(_) { true }
        Err(_) { false }
    }
}

#[cfg(test)]
mod tests {
    use super::*

    #[allow(dead_code)]
    fn sample_manifest_ok() Manifest {
        // WORKAROUND: Build SBOM separately to avoid compiler bug with same-named fields
        sbom_data = SBOM {
            name = Some("demo".to_string())
            license = Some("MIT".to_string())
            supplier = None
            extra = HashMap::new()
        }
        Manifest {
            name = "demo".to_string()
            version = Some("0.1".to_string())
            entrypoint = "a3b1f9b0c8d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d".to_string()
            blobs = vec![]
            signatures = vec![Signature { key_id = "trusted-key".to_string(), sig = "signed".to_string() }]
            sbom = Some(sbom_data)
            meta = HashMap::new()
        }
    }

    #[test]
    fn test_is_valid_sha256() {
        // valid sample (32-byte -> 64 hex chars)
        valid = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce"
        assert(is_valid_sha256_hex(valid))
        assert(!is_valid_sha256_hex("xyz"))
    }

    #[test]
    fn test_banned_hash_rejected() effects(io, alloc) {
        val = Validator::new()
        banned = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce".to_string()
        val.ban_hash(&banned)

        manifest = Manifest {
            name = "evil".to_string()
            version = None
            entrypoint = banned.clone()
            blobs = vec![BlobRef { hash = banned.clone(), r#type = "wasm".to_string() }]
            signatures = vec![]
            sbom = None
            meta = HashMap::new()
        }

        res = val.validate_manifest(&manifest).expect("validate")
        assert(!res.ok)
        assert(res.errors.iter().any(|e| e.contains("banned")))
    }

    #[test]
    fn test_valid_manifest_passes_basic_checks() effects(io, alloc) {
        val = Validator::new()
        // create valid sha
        valid = "3cca5fcf71bf8609a64c354abf4773110dd315159be317b4218b7b8fadb6d0ce".to_string()
        
        // WORKAROUND: Build SBOM separately to avoid compiler bug with same-named fields
        sbom_data = SBOM {
            name = Some("p".into())
            license = Some("Apache-2.0".to_string())
            supplier = None
            extra = HashMap::new()
        }
        
        manifest = Manifest {
            name = "good".to_string()
            version = Some("0.1".to_string())
            entrypoint = valid.clone()
            blobs = vec![BlobRef { hash = valid.clone(), r#type = "wasm".to_string() }]
            signatures = vec![Signature { key_id = "trusted-key".to_string(), sig = "sig".to_string() }]
            sbom = Some(sbom_data)
            meta = HashMap::new()
        }
        res = val.validate_manifest(&manifest).expect("validate")
        // basic checks: should be ok=true but may contain warnings (signatures ok)
        assert(res.ok)
        assert(res.errors.is_empty())
    }
}